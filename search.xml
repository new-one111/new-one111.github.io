<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在开始之前</title>
    <url>/2022/01/12/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D/</url>
    <content><![CDATA[<p>2022 - 1 - 12 </p>
<p>今天计划很久的博客终于搭建好了，介绍一下，这里是傻傻分不清（c s p）的博客。</p>
<p>从今以后，这里将是属于我自己的一片天地，我会将记录自己的学习、生活的点点滴滴。</p>
<span id="more"></span>

<h1 id="傻傻分不清的博客"><a href="#傻傻分不清的博客" class="headerlink" title="傻傻分不清的博客"></a>傻傻分不清的博客</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大二块结束才搭建了自己的博客，大概是自己想要做出一些改变叭，尽管姗姗来迟，但我会尽自己所能，充实完善它，与它共同成长。</p>
<h2 id="搭建博客的初衷"><a href="#搭建博客的初衷" class="headerlink" title="搭建博客的初衷"></a>搭建博客的初衷</h2><h3 id="主要原因"><a href="#主要原因" class="headerlink" title="主要原因"></a>主要原因</h3><p>我平时是属于热衷于记笔记的那一类，但上了大学后，学的东西杂乱无章，尤其是学习计算机技术，各式代码和算法眼花缭乱，对于这些，传统的纸质笔记乃至当下热门的电子笔记都不太适合代码、算法的整理，这导致了什么？每次学东西就得现查，互联网信息杂乱无章，对于久远的知识，或是掌握不牢固的知识，没有一种合理的方式去整理归纳。就算当场掌握知识，时间会带走一切，等需要时，又要从繁杂的信息中筛选自己所需，这不仅浪费时间，更会产生对代码的厌恶。</p>
<h3 id="次要原因"><a href="#次要原因" class="headerlink" title="次要原因"></a>次要原因</h3><p>计算机人怎么能没有博客QAQ</p>
<h2 id="博客介绍"><a href="#博客介绍" class="headerlink" title="博客介绍"></a>博客介绍</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>本博客采用hexo框架，由NexT驱动</p>
<p><a href="https://hexo.io/">hexo官网</a>      </p>
<p><a href="http://theme-next.iissnan.com/getting-started.html">NexT使用文档</a></p>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>为了尽可能减少 “记笔记” 的麻烦，过于复杂的方式反而会增加压力，目前博客主要使用 Markdown 语言</p>
<h4 id="简单语法介绍语法介绍"><a href="#简单语法介绍语法介绍" class="headerlink" title="简单语法介绍语法介绍"></a>简单语法介绍语法介绍</h4><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5><p>要加粗的文字左右分别用两个*号包起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**字体加粗**</span><br></pre></td></tr></table></figure>

<p><strong>字体加粗</strong></p>
<h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5><p>要倾斜的文字左右分别用一个*号包起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*字体倾斜*</span><br></pre></td></tr></table></figure>

<p><em>字体倾斜</em>  </p>
<h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><p>要加删除线的文字左右分别用两个~~号包起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~这是删除线~~</span><br></pre></td></tr></table></figure>

<p><del>这是删除线</del></p>
<h5 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[title](Web site Link)</span><br><span class="line">[我的github](https://github.com/new-one111)</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/new-one111">我的github</a></p>
<h4 id="hexo-更新"><a href="#hexo-更新" class="headerlink" title="hexo 更新"></a>hexo 更新</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd 命令行下输入</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s // 预览</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<hr>
<p>OVER</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>Minesweeping</title>
    <url>/2022/01/25/Minesweeper/</url>
    <content><![CDATA[<p>Mine sweeping 扫雷游戏（纯暴力遍历）    <a href="https://www.dotcpp.com/oj/problem1096.html">原题连接</a></p>
<span id="more"></span>

<h1 id="扫雷"><a href="#扫雷" class="headerlink" title="扫雷"></a>扫雷</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Minesweeper Have you ever played Minesweeper? This cute little game comes with a certain operating system whose name we can’t remember. The goal of the game is to find where all the mines are located within a M x N field. The game shows a number in a square which tells you how many mines there are adjacent to that square. Each square has at most eight adjacent squares. The 4 x 4 field on the left contains two mines, each represented by a ``*’’ character. If we represent the same field by the hint numbers described above, we end up with the field on the right: <em>… …. .</em>.. …. <em>100 2210 1</em>10 1110</p>
<p>翻译 【 <a href="https://fanyi.so.com/#">前往360翻译</a> 】</p>
<p>扫雷 你玩过扫雷吗？这个可爱的小游戏带有一个我们不记得名字的操作系统。游戏的目标是找出所有地雷在 M x N 区域内的位置。游戏会在方块中显示一个数字，告诉您该方块附近有多少地雷。每个方格最多有八个相邻方格。左边的 4 x 4 区域包含两个地雷，每个地雷由一个“<em>”字符表示。如果我们用上述提示编号表示相同的字段，我们最终会得到右侧的字段：</em>… …. .*.. …. <em>100 2210 1</em>10 1110</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>The input will consist of an arbitrary number of fields. The first line of each field contains two integers n and m ( 0 &lt; n, m$ \le$100) which stand for the number of lines and columns of the field, respectively. Each of the next n lines contains exactly m characters, representing the field. Safe squares are denoted by <code>&#39;.&#39; and mine squares by &#39;*&#39;</code>, both without the quotes. The first field line where n = m = 0 represents the end of input and should not be processed.</p>
<p>翻译 【 <a href="https://fanyi.so.com/#">前往360翻译</a> 】</p>
<p>输入将由任意数量的字段组成。每个字段的第一行包含两个整数 n 和 m ( 0 &lt; n, m$ \le$100)，分别代表字段的行数和列数。接下来的 n 行中的每一行都恰好包含 m 个字符，代表该字段。安全方格用“.”表示，地雷方格用“*,”表示，两者都没有引号。n = m = 0 的第一条场线表示输入结束，不应处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">*...</span><br><span class="line">....</span><br><span class="line">.*..</span><br><span class="line">....</span><br><span class="line">3 5</span><br><span class="line">**...</span><br><span class="line">.....</span><br><span class="line">.*...</span><br><span class="line">0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each field, print the message Field #x: on a line alone, where x stands for the number of the field starting from 1. The next n lines should contain the field with the ``.’’ characters replaced by the number of mines adjacent to that square. There must be an empty line between field outputs.</p>
<p>翻译 【 <a href="https://fanyi.so.com/#">前往360翻译</a> 】</p>
<p>对于每个字段，仅在一行上打印消息 Field #x:，其中 x 代表从 1 开始的字段编号。接下来的 n 行应包含字段，并将“.”字符替换为那个广场附近的地雷。字段输出之间必须有一个空行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段#1：</span><br><span class="line">*100</span><br><span class="line">2210</span><br><span class="line">1*10</span><br><span class="line">1110</span><br><span class="line"></span><br><span class="line">字段#2：</span><br><span class="line">**100</span><br><span class="line">33200</span><br><span class="line">1*100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>根据题意找出每一个坐标周围的所有炸弹数，简单分析可以知道，可以对当前的坐标遍历四周8个（最多）位置，每当出现了一个炸弹，计数 ans ++…….</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> field[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> <span class="comment">// 对当前的field[i][j] 计数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(field[i][j])</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = i - <span class="number">1</span>; t &lt;= i + <span class="number">1</span>;t ++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> T = j - <span class="number">1</span>; T &lt;= j + <span class="number">1</span>;T ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(field[t][T])</span><br><span class="line">				ans[i][j]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 初始化数组 field  ans</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>;i ++)&#123;</span><br><span class="line">			<span class="built_in">memset</span>(field[i],<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(field[i]));</span><br><span class="line">			<span class="built_in">memset</span>(ans[i], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span> ch;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i ++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m;j ++)&#123;</span><br><span class="line">				cin &gt;&gt; ch;</span><br><span class="line">				<span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">					field[i][j] = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">if</span>(ch == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">					field[i][j] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// eeee 太水了</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i ++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m;j ++)&#123;</span><br><span class="line">				<span class="built_in">find</span>(i, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Field #&quot;</span> &lt;&lt; idx++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i ++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m;j ++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(field[i][j])</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					cout &lt;&lt; ans[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>就当做记录吧</p>
<p><em><strong>over~</strong></em></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Cylinder</title>
    <url>/2022/01/25/Cylinder/</url>
    <content><![CDATA[<p>Cylinder 【<del>学霸题</del>】圆柱体    <a href="https://www.dotcpp.com/oj/problem1111.html">原题连接</a></p>
<span id="more"></span>

<h1 id="圆柱体"><a href="#圆柱体" class="headerlink" title="圆柱体"></a>圆柱体</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Using a sheet of paper and scissors, you can cut out two faces to form a cylinder in the following way:</p>
<p>Cut the paper horizontally (parallel to the shorter side) to get two rectangular parts.</p>
<p>From the first part, cut out a circle of maximum radius. The circle will form the bottom of the cylinder.</p>
<p>Roll the second part up in such a way that it has a perimeter of equal length with the circle’s circumference, and attach one end of the roll to the circle. Note that the roll may have some overlapping parts in order to get the required length of the perimeter.</p>
<p>Given the dimensions of the sheet of paper, can you calculate the biggest possible volume of a cylinder which can be constructed using the procedure described above?</p>
<p>翻译【<a href="https://translate.google.cn/?sl=en&tl=zh-CN&op=translate">点击前往谷歌翻译</a>】</p>
<p>使用一张纸和剪刀，您可以通过以下方式剪出两个面以形成一个圆柱体：</p>
<p>水平切割纸张（平行于较短的一侧）以获得两个矩形部分。</p>
<p>从第一部分切出一个最大半径的圆。圆圈将形成圆柱体的底部。</p>
<p>将第二部分卷起来，使其周长与圆的周长相等，并将卷的一端连接到圆上。请注意，为了获得所需的周长长度，卷筒可能有一些重叠部分。</p>
<p>给定这张纸的尺寸，你能计算出可以使用上述过程构造的圆柱体的最大可能体积吗？</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>The input consists of several test cases. Each test case consists of two numbers w and h (1 ≤ w ≤ h ≤ 100), which indicate the width and height of the sheet of paper.</p>
<p>The last test case is followed by a line containing two zeros.</p>
<p>翻译【<a href="https://translate.google.cn/?sl=en&tl=zh-CN&op=translate">点击前往谷歌翻译</a>】</p>
<p>输入由几个测试用例组成。每个测试用例由两个数字 w 和 h（1 ≤ w ≤ h ≤ 100）组成，分别表示纸张的宽度和高度。</p>
<p>最后一个测试用例后面是包含两个零的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 10</span><br><span class="line">10 50</span><br><span class="line">10 30</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>For each test case, print one line with the biggest possible volume of the cylinder. Round this number to 3 places after the decimal point.</p>
<p>翻译【<a href="https://translate.google.cn/?sl=en&tl=zh-CN&op=translate">点击前往谷歌翻译</a>】</p>
<p>对于每个测试用例，打印一条具有最大可能圆柱体体积的行。将此数字四舍五入到小数点后 3 位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">54.247</span><br><span class="line">785.398</span><br><span class="line">412.095</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>根据题意</p>
<p>可以分为两种情况：</p>
<hr>
<img src="C:\Users\CHEN\blog\source\images\Cylinder.png" style="zoom:75%;" />



<p>【Ⅰ】 以 W 为周长 h - 2 r 为高的圆柱体 </p>
<p>条件 ：</p>
<p>W &gt;= 2 × pi × r   ==&gt;   r&lt;= w / (2 × pi)</p>
<p>V1 = pi × r × r ×（h - 2 × r） </p>
<p>【Ⅱ】以 h - 2 r为周长 w 为高的圆柱体</p>
<p>条件：</p>
<p>h - 2r &gt;= 2 × pi × r   ==&gt;   r &lt;= h / (2 × r + 2 × pi)</p>
<p>V2 = pi × r × r × w</p>
<p>情况【Ⅱ】中，r × 2 可能大于 w， 故 当 r × 2 &gt; w 时 r 只能 等于 w/2.</p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926535898</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> h,w;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; w &gt;&gt; h)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w == <span class="number">0</span> || h == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">double</span> r,v1,v2;</span><br><span class="line">        r = w / (<span class="number">2</span>*pi);</span><br><span class="line">        v1 = pi * r * r * (h - <span class="number">2</span> * r);</span><br><span class="line">        r = h / (<span class="number">2</span>*pi + <span class="number">2</span>); <span class="comment">// 情况2</span></span><br><span class="line">        <span class="keyword">if</span>(r*<span class="number">2</span> &gt; w) r = w/<span class="number">2</span>;</span><br><span class="line">        v2 = pi * r * r * w;</span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; <span class="built_in">max</span>(v1,v2) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>over~</strong></em></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>最长连续因子</title>
    <url>/2022/01/14/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90/</url>
    <content><![CDATA[<p>【最长连续因子】给定一个数，求出它的最大连续因子<img src="https://t10.baidu.com/it/u=1969343754,3631670350&fm=175&app=25&f=JPEG?w=639&h=452&s=5552ED3A5B5346C00C75B5D5030050A0" style="zoom:60%;" /></p>
<span id="more"></span>

<h1 id="最长连续因子"><a href="#最长连续因子" class="headerlink" title="最长连续因子"></a>最长连续因子</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个正整数 <em>N</em> 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 <em>N</em>，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个正整数 <em>N</em>（1&lt;<em>N</em>&lt;2^31）。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 <code>因子1*因子2*……*因子k</code> 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">630</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出:</span><br><span class="line">3</span><br><span class="line">5*6*7</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>采用暴力解法，只需要知道当前的 i 能向后枚举多少位，每次更新，确保保留的是 <code>最大枚举数</code> 和 对应的 <code>i</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count -&gt; 最大枚举数</span><br><span class="line">idx -&gt; 对应的 i</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nowcount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="built_in">sqrt</span>(N) + <span class="number">1</span>;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(N % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> n = N,nowidx= <span class="number">1</span>;</span><br><span class="line">        nowcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;n % j == <span class="number">0</span>;j ++)&#123;</span><br><span class="line">            nowcount ++;</span><br><span class="line">            n/=j;</span><br><span class="line">            nowidx = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; nowcount)</span><br><span class="line">            count = nowcount, idx = nowidx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输 出</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt;endl &lt;&lt; N &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= count;i ++,idx ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != count) cout &lt;&lt; idx &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; idx &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：当最大枚举数为 1 时，按照提议需要输出 1 \n N 例如 3 : 1 \n 3。</p>
<hr>
<p><em><strong>OVER~</strong></em></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的桶排序</title>
    <url>/2022/01/12/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>(@_@)~</p>
<span id="more"></span>

<h1 id="排序算法之桶排序"><a href="#排序算法之桶排序" class="headerlink" title="排序算法之桶排序"></a>排序算法之桶排序</h1><h2 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h2><p>将一组数升序排序，保证所有数据处于[a,b]区间内。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>将[a,b]均匀的划分为 n 份，每一份就是一个桶，将所有的数据按大小放到桶里，每个桶独立排序，排序按顺序遍历输出每一个桶中的数据。</p>
<hr>
<img src="https://img-blog.csdnimg.cn/20190219081232815.png" style="zoom:50%;" />

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="0-1-排序"><a href="#0-1-排序" class="headerlink" title="[0,1)排序"></a>[0,1)排序</h3><p>问题描述：将{0.12,0.07,0.89,0.54,0.36,0,73,0.82,0.01,0.32，0.15}升序排列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">10</span><br><span class="line">0.12 0.07 0.89 0.54 0.36 0.73 0.82 0.01 0.32 0.15</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出:</span><br><span class="line">0.01 0.07 0.12 0.15 0.32 0.36 0.54 0.73 0.82 0.89</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> a, fid;</span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; basket[<span class="number">5</span>];    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    fid = <span class="number">1</span> / <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; fid)</span><br><span class="line">            basket[<span class="number">0</span>].<span class="built_in">push_back</span>(a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">2</span> * fid)</span><br><span class="line">            basket[<span class="number">1</span>].<span class="built_in">push_back</span>(a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">3</span> * fid)</span><br><span class="line">            basket[<span class="number">2</span>].<span class="built_in">push_back</span>(a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">4</span> * fid)</span><br><span class="line">            basket[<span class="number">3</span>].<span class="built_in">push_back</span>(a);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            basket[<span class="number">4</span>].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(basket[<span class="number">0</span>].<span class="built_in">begin</span>(), basket[<span class="number">0</span>].<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(basket[<span class="number">1</span>].<span class="built_in">begin</span>(), basket[<span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(basket[<span class="number">2</span>].<span class="built_in">begin</span>(), basket[<span class="number">2</span>].<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(basket[<span class="number">3</span>].<span class="built_in">begin</span>(), basket[<span class="number">3</span>].<span class="built_in">end</span>()); </span><br><span class="line">    <span class="built_in">sort</span>(basket[<span class="number">4</span>].<span class="built_in">begin</span>(), basket[<span class="number">4</span>].<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt;::iterator it = basket[i].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (it; it != basket[i].<span class="built_in">end</span>();it ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (*it) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊的划分"><a href="#特殊的划分" class="headerlink" title="特殊的划分"></a>特殊的划分</h3><p>输入10个整数，保证十个数在0~100之间，排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义  bool basket[101] 初始化为false;</span><br><span class="line">循环输入 a 同时 basket[a] = true;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P1059">洛谷P1059明明的随机数</a></p>
<hr>
<p>OVER~</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title>ASCII 码对照表</title>
    <url>/2022/01/15/%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>这是一个 ASCII 码对照表</p>
<span id="more"></span>

<h1 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a><em>ASCII码表</em></h1><p><code>32 -&gt; 126 </code>是可见的<code>ASCII字符</code> </p>
<img src="https://www.asciitable.com/asciifull.gif" alt="ASCII码表" style="zoom:200%;" />

<h1 id="ASCII扩展码"><a href="#ASCII扩展码" class="headerlink" title="ASCII扩展码"></a>ASCII扩展码</h1><img src="https://www.asciitable.com/extend.gif" alt="ASCII扩展码" style="zoom:200%;" />]]></content>
      <categories>
        <category>知识散记</category>
      </categories>
      <tags>
        <tag>ASCII码</tag>
      </tags>
  </entry>
  <entry>
    <title>链式向前星</title>
    <url>/2022/02/01/%E9%93%BE%E5%BC%8F%E5%90%91%E5%89%8D%E6%98%9F/</url>
    <content><![CDATA[<p>当我们遇到图论题，通常会使用邻接表，邻接矩阵来存储图。邻接矩阵易于实现，但操作不便，邻接表实现起来较复杂，但易于操作。这里介绍一种简单，折中的存储方式 ——链式向前星</p>
<span id="more"></span>

<h1 id="链式向前星"><a href="#链式向前星" class="headerlink" title="链式向前星"></a>链式向前星</h1><h2 id="数组模拟邻接表"><a href="#数组模拟邻接表" class="headerlink" title="数组模拟邻接表"></a>数组模拟邻接表</h2><p>链式向前星的实质就是用数组模拟邻接表，邻接表是带头结点数组的链表，需要结合结构体指针来实现，实现起来比较复杂。</p>
<p>用 head 数组来存 head[i] = j 即 以 i  为端点的 第 j 条边， next 存的是 这条边的 <strong>起始端点</strong>，to 存的是  <strong>末端点</strong></p>
<p>例如存如下图（边的两端）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>

<p>head[1] = 2, next[1] = -1, next[2] = 1, to[1] = 2, to[2] = 3;</p>
<p>head[2] = 4, next[3] = -1, next[4] = 4, to[3] = 4, to[4] = 5;</p>
<p><code>head 初始化为 -1</code></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法 1 </span></span><br><span class="line"><span class="comment">// N 为节点数, M 为边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="keyword">int</span> head[N],idx = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    edge[idx].to = b;</span><br><span class="line">    edge[idx].next = head[a];</span><br><span class="line">    edge[idx].w = c;</span><br><span class="line">    head[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="comment">// 添加数据</span></span><br><span class="line">    <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[<span class="number">1</span>]; ~i ;i = edge[i].next)&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; edge[i].to &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// operation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法 2</span></span><br><span class="line"><span class="keyword">int</span> head[N],ne[M],e[M],w[M],idx = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = head[a];</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    head[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[<span class="number">1</span>]; ~i ;i = ne[i])&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; e[i] &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// operation</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p><em><strong>over~</strong></em></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2022/02/06/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p><strong>时间复杂度</strong></p>
<p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。</p>
<span id="more"></span>

<p>原题传送门</p>
<p>[**洛谷P3952**]([P3952 <a href="https://www.luogu.com.cn/problem/P3952">NOIP2017 提高组] 时间复杂度 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</p>
<p>[**AcWing：526. 时间复杂度**](<a href="https://www.acwing.com/problem/content/528/">526. 时间复杂度 - AcWing题库</a>)</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序，于是你的机会来啦！</p>
<p>下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 </p>
<p>A++ 语言的循环结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F i x y</span><br><span class="line">    循环体</span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<p>其中 <code>F i x y</code> 表示新建变量 i（变量 i 不可与未被销毁的变量重名）并初始化为 x，然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。</p>
<p>每次循环结束后 i 都会被修改成 i+1，一旦 i 大于 y 终止循环。</p>
<p>x 和 y 可以是正整数（x 和 y 的大小关系不定）或变量 n。</p>
<p>n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 </p>
<p><code>E</code> 表示循环体结束。</p>
<p>循环体结束时，这个循环体新建的变量也被销毁。 </p>
<p>注：本题中为了书写方便，在描述复杂度时，使用大写英文字母 <code>O</code> 表示通常意义下 <code>Θ</code> 的概念。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入文件第一行一个正整数 t，表示有 t（t≤10）个程序需要计算时间复杂度。</p>
<p>每个程序我们只需抽取其中 <code>F i x y</code> 和 <code>E</code> 即可计算时间复杂度。注意：循环结构允许嵌套。  </p>
<p>接下来每个程序的第一行包含一个正整数 L 和一个字符串，L 代表程序行数，字符串表示这个程序的复杂度，<code>O(1)</code> 表示常数复杂度，<code>O(n^w)</code> 表示复杂度为 n^w，其中 w 是一个小于 100 的正整数（输入中不包含引号），输入保证复杂度只有 <code>O(1)</code> 和 <code>O(n^w)</code> 两种类型。 </p>
<p>接下来 L 行代表程序中循环结构中的 <code>F i x y</code> 或者 <code>E</code>。 </p>
<p>程序行若以 <code>F</code> 开头，表示进入一个循环，之后有空格分离的三个字符（串）<code>i x y</code>，其中 i 是一个小写字母（保证不为 n），表示新建的变量名，x 和 y 可能是正整数或 n，已知若为正整数则一定小于 100。  </p>
<p>程序行若以 <code>E</code> 开头，则表示循环体结束。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出文件共 t 行，对应输入的 t 个程序，每行输出 <code>Yes</code> 或 <code>No</code> 或者 <code>ERR</code>，若程序实际复杂度与输入给出的复杂度一致则输出 <code>Yes</code>，不一致则输出 <code>No</code>，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ② 新建的变量与已经存在但未被销毁的变量重复两种情况），则输出 <code>ERR</code>。</p>
<p>注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 <code>ERR</code>。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">2 O(1)</span><br><span class="line">F i 1 1</span><br><span class="line">E</span><br><span class="line">2 O(n^1)</span><br><span class="line">F x 1 n</span><br><span class="line">E</span><br><span class="line">1 O(1)</span><br><span class="line">F x 1 n</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 5 n</span><br><span class="line">F y 10 n</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 9 n</span><br><span class="line">E</span><br><span class="line">F y 2 n</span><br><span class="line">E</span><br><span class="line">4 O(n^1)</span><br><span class="line">F x 9 n</span><br><span class="line">F y n 4</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(1)</span><br><span class="line">F y n 4</span><br><span class="line">F x 9 n</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 1 n</span><br><span class="line">F x 1 10</span><br><span class="line">E</span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">ERR</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">ERR</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这是一道模拟题</p>
<p><strong>字符串</strong></p>
<p><code>输入的时间复杂度判断</code> : 题目中只会出现两种时间复杂度<code>O(1)</code>、 <code>O(n^w)</code> 而 O(1) 的 字符串长度为 4 , O(n ^ w)的字符长度一定大于 4 ，以此 为判断。</p>
<p><code>字符串读入</code>：一整行的读入，使用<code>getline(is_,string)</code>读入带空格的字符串, c++ 11 中 gets() 函数不被定义，<code>online judge</code>可能报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure>

<p><strong>F E 匹配</strong></p>
<p>判断 F E 是否匹配，类似于<strong>括号匹配问题</strong> 定义一个<code>FEn</code> 当读入 F 时 FEn ++, 读入 E 时FEn –, 当 <code>FEn &lt; 0</code> ||<code>（读入最后一行代码时）FEn != 0</code>，表明 F E是 不匹配的。</p>
<p>注意：输入的 L 如果为奇数 如 1 ，3 ，5 那么 ，E F 一定不匹配</p>
<p><strong>时间复杂度不匹配</strong></p>
<p>根据O(1) 和 O(n^w) 的字符串长度 得到 目标时间复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取 w </span></span><br><span class="line">	<span class="keyword">if</span>(the_o)&#123;</span><br><span class="line">		w = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">strlen</span>(time);i ++)</span><br><span class="line">			<span class="keyword">if</span>(time[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; time[i] &lt;= <span class="string">&#x27;9&#x27;</span>) w = w * <span class="number">10</span> + time[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>对于 匹配的逻辑，当我们输入 E 时，就是结束一层循环，最近的 F 与这个 E 匹配，简而言之就是 <code>后输入的  先被匹配</code>，用栈存：检测到读入的是 F 语句，就将 <code>F i x y</code> 中的 i x y 入栈，遇到 E 就将 i x y 出栈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string i,x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &lt; L)&#123;</span><br><span class="line">    <span class="built_in">getline</span>(a);</span><br><span class="line">    node stack[<span class="number">101</span>]; <span class="comment">// 数 组 栈</span></span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">0</span>, top = base;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// 入 栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// 出 栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出栈之前 遍历 整个栈 ，判断是否 <code>变量重复</code>。</p>
<p>对于时间复杂度的判断，定义一个 string <code>stime</code>字符串，出栈之前 将 当前循环的时间复杂度存入stime，</p>
<p>循序截断 ：1</p>
<p>常数复杂度：c</p>
<p>n^1复杂度：n</p>
<p>计算最大时间复杂度并取最大值。</p>
<p>例如对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F a 76 n</span><br><span class="line">F b 34 n</span><br><span class="line">F c 16 n</span><br><span class="line">F d 2 n</span><br><span class="line">F e 5 n</span><br><span class="line">F f 87 n</span><br><span class="line">F g 8 n</span><br><span class="line">F h 3 n</span><br><span class="line">F i n 17</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stime : FFFFFFFFF1EnEnEnEnEnEnEnEnE</span><br><span class="line">时间复杂度为 n^8</span><br></pre></td></tr></table></figure>

<p><code>1</code>状态为截断，即 <code>1</code>循环以内的都不执行，不算时间复杂度</p>
<p>体现在stime就是1以前的不计算时间复杂度，因为，1以前的是先出栈的，在1循环的内部，被截断</p>
<p>通过得到的实际时间复杂度，与目标时间复杂度相符为 Yes ,否为 No。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	string i,x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tonumber</span><span class="params">(string a)</span> <span class="comment">// 将 string 转为 int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = a.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">int</span>  n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i ++)&#123;</span><br><span class="line">		n = n * <span class="number">10</span> + a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkTime</span><span class="params">(string a)</span> <span class="comment">// 根据 stime 判断时间复杂度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = a.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>,maxt = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> stack[<span class="number">1005</span>];</span><br><span class="line">	<span class="keyword">int</span> base = <span class="number">0</span>,top = base;</span><br><span class="line">	<span class="keyword">bool</span> change = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">bool</span> fg[len + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(fg,<span class="literal">true</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(fg));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i ++)&#123;</span><br><span class="line">		t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[i] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; (a[i + <span class="number">1</span>] == <span class="string">&#x27;F&#x27;</span> || a[i + <span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>))&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &gt;= <span class="number">0</span> ;j --)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[j] == <span class="string">&#x27;n&#x27;</span>) t ++;</span><br><span class="line">				<span class="keyword">if</span>(a[j] == <span class="string">&#x27;F&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span>(a[j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// 读 到 1 就 可 以 退 出</span></span><br><span class="line">					<span class="keyword">if</span>(maxt &lt; t) maxt = t;</span><br><span class="line">					t = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span>(maxt &lt; t) maxt = t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L,FEn = <span class="number">0</span>,n,w; <span class="comment">// O(n^w)</span></span><br><span class="line">	<span class="keyword">bool</span> the_o = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">char</span> time[<span class="number">10</span>];</span><br><span class="line">	cin &gt;&gt; L &gt;&gt; time;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(time) == <span class="number">4</span>) the_o = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(the_o)&#123;</span><br><span class="line">		w = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">strlen</span>(time);i ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(time[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; time[i] &lt;= <span class="string">&#x27;9&#x27;</span>) w = w * <span class="number">10</span> + time[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; the_o &lt;&lt; endl;</span></span><br><span class="line">	string code[<span class="number">105</span>];</span><br><span class="line">	<span class="keyword">if</span>(L&amp;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; L;i ++)&#123;</span><br><span class="line">			<span class="built_in">getline</span>(cin,code[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// @ L 为 奇 数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ERR&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">bool</span> outcome = <span class="literal">true</span>;</span><br><span class="line">		string stime = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		node stack[<span class="number">101</span>];</span><br><span class="line">		<span class="keyword">int</span> top = <span class="number">0</span>, base = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> max_w = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">bool</span> Notips = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; L;i ++)&#123;</span><br><span class="line">			<span class="built_in">getline</span>(cin,code[i]);</span><br><span class="line">			<span class="comment">// cout &lt;&lt; code[i] &lt;&lt; endl;</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span>(code[i][<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">				FEn ++;</span><br><span class="line">				stime = stime + <span class="string">&quot;F&quot;</span>;</span><br><span class="line">				<span class="comment">// 变 量 入 栈</span></span><br><span class="line">				<span class="keyword">bool</span> spaceshow = <span class="literal">false</span>;</span><br><span class="line">				stack[top].i = code[i][<span class="number">2</span>];</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">4</span>;j &lt; code[i].<span class="built_in">length</span>();j ++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(code[i][j] == <span class="string">&#x27; &#x27;</span>) &#123;spaceshow = <span class="literal">true</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">					<span class="keyword">if</span>(!spaceshow) stack[top].x += code[i][j];</span><br><span class="line">					<span class="keyword">else</span> stack[top].y += code[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//cout &lt;&lt;&quot;栈：&quot;&lt;&lt; stack[top].i &lt;&lt; &quot; &quot; &lt;&lt; stack[top].x &lt;&lt; &quot; &quot; &lt;&lt; stack[top].y &lt;&lt; endl;   // 调 试 </span></span><br><span class="line">				top ++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">bool</span> once = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(code[i][<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; FEn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				FEn --;</span><br><span class="line">				once = <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">// 1. 判 断 变 量 重 名</span></span><br><span class="line">				<span class="keyword">int</span> ftop = base;</span><br><span class="line">				<span class="comment">//cout &lt;&lt; &quot;zhan:&quot; &lt;&lt;base &lt;&lt; &quot; &quot; &lt;&lt; top &lt;&lt;endl;   // 调 试 </span></span><br><span class="line">				<span class="keyword">for</span>(;ftop &lt; top - <span class="number">1</span>;ftop ++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(stack[ftop].i == stack[top - <span class="number">1</span>].i) &#123;outcome = <span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 2. 标 记 时 间 复 杂 度 @ stime</span></span><br><span class="line">				<span class="comment">//stime = &quot;F&quot; + stime;</span></span><br><span class="line">				<span class="keyword">if</span>(stack[top - <span class="number">1</span>].x == <span class="string">&quot;n&quot;</span> &amp;&amp; stack[top - <span class="number">1</span>].y != <span class="string">&quot;n&quot;</span>) stime += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(stack[top - <span class="number">1</span>].y == <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span>(stack[top - <span class="number">1</span>].x != <span class="string">&quot;n&quot;</span>) stime += <span class="string">&quot;n&quot;</span>;</span><br><span class="line">					<span class="keyword">else</span> stime += <span class="string">&quot;c&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Tonumber</span>(stack[top - <span class="number">1</span>].x) &gt; <span class="built_in">Tonumber</span>(stack[top <span class="number">-1</span>].y)) stime += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Tonumber</span>(stack[top - <span class="number">1</span>].x) &lt;= <span class="built_in">Tonumber</span>(stack[top <span class="number">-1</span>].y)) stime += <span class="string">&quot;c&quot;</span>;</span><br><span class="line">				stime += <span class="string">&quot;E&quot;</span>;</span><br><span class="line">				stack[top - <span class="number">1</span>] = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">				top--; <span class="comment">// 遇 到 E 就 将 变 量 出 栈</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(code[i][<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; !once) FEn --;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(FEn == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="comment">//cout &lt;&lt; &quot;stime :&quot; &lt;&lt; stime &lt;&lt; endl;   // 调 试 </span></span><br><span class="line">				<span class="keyword">int</span> t = <span class="built_in">checkTime</span>(stime);</span><br><span class="line">				<span class="keyword">if</span>(max_w &lt; t) max_w = t;</span><br><span class="line">				stime = <span class="string">&quot;&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(FEn &lt; <span class="number">0</span> || (FEn != <span class="number">0</span> &amp;&amp; i == L - <span class="number">1</span>)) &#123; outcome = <span class="literal">false</span>;&#125; <span class="comment">// @ EF 不匹配</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;the_w :&quot; &lt;&lt; max_w &lt;&lt; endl;   // 调 试 </span></span><br><span class="line">		<span class="keyword">if</span>(the_o &amp;&amp; max_w != w) Notips = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			Notips = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!outcome) &#123;cout &lt;&lt; <span class="string">&quot;ERR&quot;</span> &lt;&lt;endl;&#125; <span class="comment">// @</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(outcome &amp;&amp; Notips)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(outcome &amp;&amp; !Notips)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t;i ++)&#123;</span><br><span class="line">		<span class="built_in">func</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>over~</strong></em></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>母牛的故事</title>
    <url>/2022/01/19/%E6%AF%8D%E7%89%9B%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>这是一个经典的递归问题</p>
<p>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请问在第n年的时候，共有多少头母牛？</p>
<span id="more"></span>

<h1 id="母牛的故事【递归】"><a href="#母牛的故事【递归】" class="headerlink" title="母牛的故事【递归】"></a>母牛的故事【递归】</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请问在第n年的时候，共有多少头母牛？</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>新生的牛在第四年初可以生小牛 </p>
<p>分析 n 的各个取值</p>
<p>n = 1 : 1</p>
<p>n = 2 : 2</p>
<p>n = 3 : 3</p>
<p>n = 4 : 4</p>
<p>n = 5 : 6</p>
<p>n = 6 : 9</p>
<p>n = 7 : 13</p>
<p>n = 8 : 19</p>
<p>…</p>
<p>不难发现 第 n 年牛的数量 = 前一年牛数 + 前三年牛数 (这是新生的牛)</p>
<p>写出递推公式 :   <em><strong>f( n ) = f(n - 1) + f(n - 3)</strong></em></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递 归</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">4</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">f</span>(n - <span class="number">1</span>) + <span class="built_in">f</span>(n - <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种写法的时间复杂度太高，原因是 f(n) 被多次重复计算</span></span><br><span class="line"><span class="comment">// 优化 记忆化递归 剪枝</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">        arr[n] = n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[n] != <span class="number">0</span>) <span class="keyword">return</span> arr[n]; <span class="comment">// 当 f n 已经有值 就直接返回</span></span><br><span class="line">    arr[n] = <span class="built_in">f</span>(n - <span class="number">1</span>) + <span class="built_in">f</span>(n - <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,arr[<span class="number">60</span>];</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= <span class="number">4</span>) arr[i] = i;</span><br><span class="line">            <span class="keyword">else</span> arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; arr[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种更好的写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,arr[<span class="number">60</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">55</span>;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= <span class="number">4</span>) arr[i] = i;</span><br><span class="line">        <span class="keyword">else</span> arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; arr[n] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>over~</strong></em></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>递推</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
