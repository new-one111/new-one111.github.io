<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前缀和</title>
      <link href="/2022/04/30/qian-zhui-he/"/>
      <url>/2022/04/30/qian-zhui-he/</url>
      
        <content type="html"><![CDATA[<p>前缀和</p><span id="more"></span><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h3 id="什么是前缀和"><a href="#什么是前缀和" class="headerlink" title="什么是前缀和"></a>什么是前缀和</h3><p>给定一个数组，求这个数组a 的和（sum）是多少， 这太简单了，直接暴力枚举每一位，并用累加就可以了</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for(auto t : a) sum += t;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在问题升级了，给你m次查询，每次询问一个n，问sum(1 ~ n)是多少？ <del>这不简单，直接暴力</del><br>n次暴力枚举，时间复杂度挠一下就上来了。 那该怎么考虑呢？</p><p>这就需要求前缀和，顾名思义，就是n 前 1~n的和，假定我们有这样一个数组b, b的下标和a一一对应，b数组存的是a的前n项和，就是 b[i] = a[1] + a[2] + a[3] + a[i - 1] + a[i];举个栗子：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">a : 1 2 3 4 5b : 1 3 6 10 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样 当我们要求前n项的和时，只需要取出 b[n], 就是我们的结果，时间复杂度是O(1)<br>是不是很香，当然我们需要预处理得出b，事时间复杂度是O(n)</p><h3 id="做个板子题"><a href="#做个板子题" class="headerlink" title="做个板子题"></a><a href="https://www.acwing.com/problem/content/797/">做个板子题</a></h3><p>输入一个长度为 n 的整数序列。</p><p>接下来再输入 m 个询问，每个询问输入一对 l,r。</p><p>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p><p><strong>输入格式</strong><br>第一行包含两个整数 n 和 m。</p><p>第二行包含 n 个整数，表示整数数列。</p><p>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</p><p><strong>输出格式</strong><br>共 m 行，每行输出一个询问的结果。</p><p><strong>数据范围</strong><br>1≤l≤r≤n,<br>1≤n,m≤100000,<br>−1000≤数列中元素的值≤1000<br><strong>输入样例</strong>：</p><pre class="line-numbers language-none"><code class="language-none">5 32 1 3 6 41 21 32 4输出样例：3610<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], s[N]; // s[] 是前缀和数组int main(){    int n,m;    scanf("%d%d",&amp;n, &amp;m);    for(int i = 1;i &lt;= n;i ++) {        cin &gt;&gt; a[i];        s[i] = s[i - 1] + a[i];    }    int l,r;    while(m --) {        scanf("%d%d",&amp;l, &amp;r);        printf("%d\n",s[r] - s[l - 1]);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a><a href="https://www.acwing.com/problem/content/798/">二维前缀和</a></h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>画个图理解一下<br><img src="/images/%E5%89%8D%E7%BC%80%E5%92%8C/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C1.jpg" alt="二维前缀和的预处理"><br><img src="/images/%E5%89%8D%E7%BC%80%E5%92%8C/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C2.jpg" alt="二维前缀和的求法"><br>输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n，m，q。</p><p>接下来 n 行，每行包含 mm 个整数，表示整数矩阵。</p><p>接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 qq 行，每行输出一个询问的结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000<br>1≤q≤200000<br>1≤x1≤x2≤n<br>1≤y1≤y2≤m<br>−1000≤矩阵内元素的值≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3 4 31 7 2 43 6 2 82 1 2 31 1 2 22 1 3 41 3 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">172721<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N = 1010;int a[N][N], s[N][N];int x1,y1,x2,y2;int main(){    int n,m,q;    scanf("%d%d%d",&amp;n,&amp;m,&amp;q);    for(int i = 1;i &lt;= n;i ++) {        for(int j = 1;j &lt;= m;j ++) {            scanf("%d",&amp;a[i][j]);            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];        }    }    while(q --) {        scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);                printf("%d\n",s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][x2 - 1]);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大晚上的给我写饿了</p>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组建树</title>
      <link href="/2022/04/28/shu-zu-jian-shu/"/>
      <url>/2022/04/28/shu-zu-jian-shu/</url>
      
        <content type="html"><![CDATA[<p>如题（—&amp;—）</p><span id="more"></span><ul><li><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784">给定一个中序序列 + 先序序列，建立一棵二叉树层序输出</a></li><li><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805069361299456">给定一个中序序列 + 后续序列，建立一棵二叉树层序输出</a></li><li><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058">给定一个序列建立一个完全二叉树</a></li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int MaxN = 1e5 + 10;int n,preorder[MaxN],postorder[MaxN],inorder[MaxN];struct TreeNode {    int val;    TreeNode *r,*l;    TreeNode(int data) : val(data),l(NULL),r(NULL) {}};TreeNode *buildTree_with_postorder(int inB,int inE,int postB,int postE) {    int i = 0;    TreeNode* root = new TreeNode(0);    root -&gt; val = postorder[postE];    while(inorder[inB + i] != root -&gt; val) i ++;    if(i &gt; 0)  root -&gt; l = buildTree_with_postorder(inB, inB + i - 1, postB, postB + i - 1); // 左子树存在    if(inB + i &lt; inE)  root -&gt; r = buildTree_with_postorder(inB + i + 1, inE, postB + i, postE - 1); // 右子树存在    return root;}TreeNode *buildTree_with_preorder(int preB,int preE,int inB,int inE) {    int i = 0;    TreeNode* root = new TreeNode(0);    root -&gt; val = preorder[preB];    while(inorder[inB + i] != root -&gt; val) i ++;        if(i &gt; 0) root -&gt; l = buildTree_with_preorder(preB + 1,preB + i,inB,inB + i - 1);    if(i + inB &lt; inE) root -&gt; r = buildTree_with_preorder(preB + i + 1, preE, inB + i + 1, inE);        return root;}void level_print(TreeNode *t) {    queue&lt;TreeNode*&gt; q;    q.push(t);    while(!q.empty()) {        t = q.front();        q.pop();        cout &lt;&lt; t-&gt;val &lt;&lt; " ";        if(t -&gt; r) q.push(t -&gt; r);        if(t -&gt; l) q.push(t -&gt; l);    }}int main(){    cin &gt;&gt; n;    // for(int i = 0;i &lt; n;i ++) cin &gt;&gt; postorder[i];    for(int i = 0;i &lt; n;i ++) cin &gt;&gt; inorder[i];    for(int i = 0;i &lt; n;i ++) cin &gt;&gt; preorder[i];        // TreeNode *t = buildTree_with_postorder(0,n - 1,0,n - 1);    TreeNode *t = buildTree_with_preorder(0,n - 1,0,n - 1);    level_print(t);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度</title>
      <link href="/2022/04/27/gao-jing/"/>
      <url>/2022/04/27/gao-jing/</url>
      
        <content type="html"><![CDATA[<p>这是一篇关于 【<strong>高精度</strong>】的随笔</p><span id="more"></span><ul><li><a href="https://www.acwing.com/problem/content/793/">高精度加法</a></li><li><a href="https://www.acwing.com/problem/content/794/">高精度减法</a></li><li><a href="https://www.acwing.com/problem/content/795/">高精度乘法</a></li><li><a href="https://www.acwing.com/problem/content/796/">高精度除法</a></li></ul><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>简而言之 ： 求 a + b 的值， a,b 的长度 满足 1 &lt;= a,b &lt;= 100000</p><p>十万位的数 我们无法用常用的 long long 、 int、 存下，自然就无法使用 cout &lt;&lt; a  + b &lt;&lt; endl; 这样的做法，那我们如何来解决这道题呢。</p><p>答案是，<code>数组模拟</code>既然存不了十万位的数，但我们可以开十万个数组，很好理解吧<br>如何来模拟呢，其实就是还原小学学的 <code>竖式计算</code><br><img src="/images/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95.jpg"><br>高精度加没有啥附加条件</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;A,B;vector&lt;int&gt; add(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B){vector&lt;int&gt;c;int t = 0;for(int i = 0;i &lt; A.size() || i &lt; B.size();i ++){if(i &lt; A.size()) t += A[i];if(i &lt; B.size()) t += B[i];c.push_back(t % 10);t /= 10;}if(t) c.push_back(t); // a + b 导致 进了一位return c;}int main(){string a,b;cin &gt;&gt; a &gt;&gt; b;for(int i = a.size() - 1;i &gt;= 0;i --) A.push_back(a[i] - '0');for(int i = b.size() - 1;i &gt;= 0;i --) B.push_back(b[i] - '0'); // A 和 B 刚好将 a ,b 逆序达到 相位对其的效果auto c = add(A,B);for(int i = c.size() - 1;i &gt;= 0;i --) cout &lt;&lt; c[i];return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>同上 求 a - b 的值，a,b的长度满足 1&lt;=a,b&lt;=100000<br>和高精度加法类似但略有不同的是，我们要拿大的减去小的，例如 a &lt; b ,求 a-b,则先求 b - a，再取反;<br><img src="/images/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95.jpg"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;A,B;bool cmp(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B) //作用等价于： A &gt; B ? true : false{if(A.size()!=B.size()) return A.size() &gt; B.size(); // 上来先根据长度判断    for(int i = A.size() - 1;i &gt;= 0;i --)        if(A[i] != B[i]) return A[i] &gt; B[i];    return true;}vector&lt;int&gt; sub(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B){    // A.size() &gt; B.size() === true;vector&lt;int&gt;c;int t = 0;for(int i = 0;i &lt; A.size();i ++){        t = A[i] - t;        if(i &lt; B.size()) t -= B[i];        c.push_back((t + 10) % 10); // 借位防止 t % 10为负数        if(t &lt; 0) t = 1; // t &lt; 0 说明 t 真的产生了借位        else t =  0;}    while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); // 删除 前导零return c;}int main(){string a,b;cin &gt;&gt; a &gt;&gt; b;for(int i = a.size() - 1;i &gt;= 0;i --) A.push_back(a[i] - '0');for(int i = b.size() - 1;i &gt;= 0;i --) B.push_back(b[i] - '0'); // A 和 B 刚好将 a ,b 逆序达到 相位对其的效果if(cmp(A,B)){        auto c = sub(A,B);        for(int i = c.size() - 1;i &gt;= 0;i --) cout &lt;&lt; c[i];    }else{        auto c = sub(B,A);        cout &lt;&lt; "-";        for(int i = c.size() - 1;i &gt;= 0;i --) cout &lt;&lt; c[i];    }return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><p>对 a 的要求不变，对 b 限制，1 &lt;= b &lt;= 10000 且 b 一定不等于 0。<br>思路： 将 b 看成一个整体<br><img src="/images/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95.png"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;A,B;vector&lt;int&gt; multi(vector&lt;int&gt;&amp;A,int b){vector&lt;int&gt;c;int t = 0;for(int i = 0;i &lt; A.size();i ++){        t = A[i] * b + t;        c.push_back(t % 10);        t /= 10;}    while(t) c.push_back(t%10),t/=10; // 把t全加进结果里 直到t == 0    while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); /// 前导零    return c;}int main(){string a;    int b;cin &gt;&gt; a &gt;&gt; b;for(int i = a.size() - 1;i &gt;= 0;i --) A.push_back(a[i] - '0');// A  刚好将 a 逆序 auto c = multi(A,b);    for(int i = c.size() - 1;i &gt;= 0;i --) cout &lt;&lt; c[i];return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>类似于高精度乘法 求 a / b 的整数 和余数</p><p><img src="/images/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95.png"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;A,B;int yushu;vector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b){vector&lt;int&gt;c;int t = 0;for(int i = 0;i &lt; A.size();i ++){        t = t * 10 + A[i];        c.push_back(t / b);        t %= b;}    yushu = t;    // 为了省事 不在这除前导零le 因为这个前导零在front位置    return c;}int main(){string a;    int b;cin &gt;&gt; a &gt;&gt; b;for(int i = 0;i &lt; a.size();i ++) A.push_back(a[i] - '0');// A  刚好将 a 逆序 auto c = div(A,b);    int i = 0;    while(i &lt; c.size() - 1 &amp;&amp; c[i] == 0) i ++;    for(;i &lt; c.size();i ++) cout &lt;&lt; c[i];    cout &lt;&lt; endl &lt;&lt; yushu &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链式向前星</title>
      <link href="/2022/04/27/lian-shi-xiang-qian-xing/"/>
      <url>/2022/04/27/lian-shi-xiang-qian-xing/</url>
      
        <content type="html"><![CDATA[<p>一种邻接表</p><span id="more"></span><p>存储图，通常会使用邻接表，邻接矩阵来存储图。邻接矩阵易于实现，但操作不便，邻接表实现起来较复杂，但易于操作。这里介绍一种简单，折中的存储方式 </p><p>​——链式向前星</p><h1 id="链式向前星"><a href="#链式向前星" class="headerlink" title="链式向前星"></a>链式向前星</h1><h2 id="数组模拟邻接表"><a href="#数组模拟邻接表" class="headerlink" title="数组模拟邻接表"></a>数组模拟邻接表</h2><p>链式向前星的实质就是用数组模拟邻接表，邻接表是带头结点数组的链表，需要结合结构体指针来实现，实现起来比较复杂。</p><p>用 head 数组来存 head[i] = j 即 以 i 为端点的 第 j 条边， next 存的是 这条边的 <strong>起始端点</strong>，to 存的是 <strong>末端点</strong></p><p>例如存如下图（边的两端）</p><pre class="line-numbers language-none"><code class="language-none">1 21 32 42 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>head[1] = 2, next[1] = -1, next[2] = 1, to[1] = 2, to[2] = 3;</p><p>head[2] = 4, next[3] = -1, next[4] = 4, to[3] = 4, to[4] = 5;</p><pre class="line-numbers language-none"><code class="language-none">head 初始化为 -1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-none"><code class="language-none">// 写法 1 // N 为节点数, M 为边数struct node{    int next,to,w;}edge[M];int head[N],idx = 1;void add(int a,int b,int c){    edge[idx].to = b;    edge[idx].next = head[a];    edge[idx].w = c;    head[a] = idx ++;}//初始化void init(){    memset(head,-1,sizeof(head));}int main(){    cin &gt;&gt; N;    // 添加数据    add(a,b,c);    // 遍历图    for(int i = head[1]; ~i ;i = edge[i].next){        cout &lt;&lt; i &lt;&lt; "-&gt;" &lt;&lt; edge[i].to &lt;&lt; endl;        // operation    }    return 0;}// 写法 2int head[N],ne[M],e[M],w[M],idx = 1;void add(int a,int b,int c){    e[idx] = b;    ne[idx] = head[a];    w[idx] = c;    head[a] = idx ++;}int main(){    memset(head,-1,sizeof(head));    for(int i = head[1]; ~i ;i = ne[i]){        cout &lt;&lt; i &lt;&lt; "-&gt;" &lt;&lt; e[i] &lt;&lt; endl;        // operation    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归之排列组合枚举</title>
      <link href="/2022/04/27/di-gui-zhi-pai-lie-zu-he/"/>
      <url>/2022/04/27/di-gui-zhi-pai-lie-zu-he/</url>
      
        <content type="html"><![CDATA[<p>排列组合</p><span id="more"></span><ul><li><a href="https://www.acwing.com/activity/content/problem/content/326/">递归实现指数型枚举</a></li><li><a href="https://www.acwing.com/activity/content/problem/content/327/">递归实现组合型枚举</a></li><li><a href="https://www.acwing.com/activity/content/problem/content/328/">递归实现排列型枚举</a></li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h3 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每行输出一种方案。</p><p>同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。</p><p>对于没有选任何数的方案，输出空行。</p><p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤15</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">322 311 31 21 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="/images/%E9%80%92%E5%BD%92/%E6%8C%87%E6%95%B0%E5%9E%8B.jpg" alt="递归指数型"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int n;bool vis[20];void dfs(int u) {if(u &gt; n) {for(int i = 1;i &lt; u;i ++) {if(vis[i]) cout &lt;&lt; i &lt;&lt;" ";}cout &lt;&lt; endl;return ;}vis[u] = true;dfs(u + 1);vis[u] = false;dfs(u + 1);}int main(){cin &gt;&gt; n;dfs(1);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h3><p>从 1∼n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>两个整数 n,m ,在同一行用空格隔开。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行 1 个。</p><p>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 <code>1 3 5 7</code> 排在 <code>1 3 6 8</code> 前面）。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>n&gt;0 ,<br>0≤m≤n ,<br>n+(n−m)≤25</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">5 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><img src="/images/%E9%80%92%E5%BD%92/%E7%BB%84%E5%90%88%E5%9E%8B.jpg" alt="递归实现组合型枚举"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int n,m;bool vis[40];void dfs(int u,int step) {if(u &gt; n + 1) return ;if(step == m) {for(int i = 1;i &lt; u;i ++) {if(vis[i]) cout &lt;&lt; i &lt;&lt; " ";}cout &lt;&lt; endl;return ;}vis[u] = true;dfs(u + 1,step + 1);vis[u] = false;dfs(u + 1,step);}int main(){cin &gt;&gt; n &gt;&gt; m;dfs(1,0);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h3><p>把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数 n。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行 1 个。</p><p>首先，同一行相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤9</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 31 3 22 1 32 3 13 1 23 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int n;bool vis[20];int ans[20];void dfs(int u) {if(u &gt; n) {for(int i = 1;i &lt; u;i ++) {cout &lt;&lt; ans[i] &lt;&lt; " ";}cout &lt;&lt; endl;return ;}for(int i = 1;i &lt;= n;i ++) {if(!vis[i]) {ans[u] = i;            vis[i] = true;            dfs(u + 1);            vis[i] = false;}}}int main(){cin &gt;&gt; n;dfs(1);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇形方阵</title>
      <link href="/2022/04/27/she-xing-fang-zhen/"/>
      <url>/2022/04/27/she-xing-fang-zhen/</url>
      
        <content type="html"><![CDATA[<p>如题</p><span id="more"></span><p>给出一个不大于 9 的正整数 n，输出 <em>n</em>×<em>n</em> 的蛇形方阵。</p><p>从左上角填上 1 开始，顺时针方向依次填入数字，如同样例所示。注意每个数字有都会占用 3 个字符，前面使用空格补齐。</p><h1 id="蛇形方阵"><a href="#蛇形方阵" class="headerlink" title="蛇形方阵"></a>蛇形方阵</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个不大于 9 的正整数 n，输出  n×n 的蛇形方阵。</p><p>从左上角填上 1 开始，顺时针方向依次填入数字，如同样例所示。注意每个数字有都会占用 3 个字符，前面使用空格补齐。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>一个整数 n  代表方阵边长</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>符合要求的:蛇:形方阵</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>输入：</p><pre class="line-numbers language-none"><code class="language-none">4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none"> 1  2  3  412 13 14  511 16 15  610  9  8  7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int n,m;int f[1001][1001];int main(){    cin &gt;&gt; n;    f[1][1] = 0;    for(int i = 1,j = 0,tot = 1;tot &lt;= n * n;){        while(j &lt; n &amp;&amp; !f[i][j + 1]) f[i][++j] = tot++;        while(i &lt; n &amp;&amp; !f[i + 1][j]) f[++i][j] = tot++;        while(j &gt; 1 &amp;&amp; !f[i][j - 1]) f[i][--j] = tot++;        while(i &gt; 1 &amp;&amp; !f[i - 1][j]) f[--i][j] = tot++;    }     for(int i = 1;i &lt;= n;i ++ ,cout &lt;&lt; endl) for(int j = 1;j &lt;= n;j ++) cout &lt;&lt; setw(3) &lt;&lt; f[i][j]; # 设置场宽    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环</title>
      <link href="/2022/04/27/yue-se-fu-huan/"/>
      <url>/2022/04/27/yue-se-fu-huan/</url>
      
        <content type="html"><![CDATA[<p>约瑟夫环</p><span id="more"></span><h1 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h1><p>传送   <a href="http://cg.sau.edu.cn/acm/submit.jsp?problemID=3354">3354. 和泉纱雾与风火轮</a></p><p>【问题描述】</p><p>这是一个炎热的冬天，纱雾妹妹派和泉正宗去参加海边party，以收集各种写真增加绘画灵感。妖精和她的小伙伴们在沙滩上围成了一个环，依次从1到n编号，纱雾指定一个数m，从1号开始报数，报到m的那个人出列给纱雾拍裙底照写真，从下一个开始从1开始依次报数，现在正宗想知道当纱雾指定m以后，最后一个出列的人是谁呢？</p><p>【输入形式】</p><p>多组输入。<br>每行输入两个数n，m，中间用空格隔开，其中0&lt;=n,m&lt;=10000，n&gt;=m。【输出形式】</p><p>对于每组输入，输出一个整数表示场上剩余的最后一个人的编号。<br>如果答案不存在（或输入非法）输出”No Solution”（不带引号）。</p><p>【样例输入】</p><pre class="line-numbers language-none"><code class="language-none">10 32 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【样例输出】</p><pre class="line-numbers language-none"><code class="language-none">42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【样例说明】</p><p>样例解释：<br>当n=10，m=3时，出列顺序为<br>3 6 9 2 7 1 8 5 10 4<br>所以答案为4.</p><h2 id="浅分析一波"><a href="#浅分析一波" class="headerlink" title="浅分析一波"></a>浅分析一波</h2><p>在 n 个人中砍掉 m 号后，若要重新开始计数 1号应该为 m+1</p><p>如此每次砍掉 m 号后 后面的数会被重新排列 即 m +1 号会被排列到零号</p><p>如下图</p><p><img src="/images/yuesefu.jpg"></p><p>如图，很清晰，the most lucky one 最后一定在 0 号位，但他原来并不是在0零号位 (•́へ•́╬) <del>可恶啊</del></p><p>我们该如何得到原来的位置呢 ⊙(・◇・)？</p><p>ei,我们可以倒过来逆推</p><p>想一想，每一次 这个 lucky one 都会向前推m位对吧（相对的）即 lucky - m % i （i 是啥 ？ i 是砍掉 x 个人的 后的 n - x ? 就是每砍一人，总数都会少一人)</p><p>上述过程逆过来描述就是 ：(lucky + m) % (i ++)</p><p>所以就有了代码思路。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;using namespace std;int n,m;bool t[10000];int main(){    while(scanf("%d%d",&amp;n,&amp;m)!=EOF)    {        memset(t,0,sizeof(t));        if(n &lt; m || m &lt;= 0 || n &lt; 0 || n &gt; 10000 || m &gt; 10000){            printf("No Solution\n");        }else{            int last = 0;            for(int i = 2;i &lt;= n;i ++){                last = (last + m) % i;            }            printf("%d\n",last + 1);        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约数</title>
      <link href="/2022/04/27/yue-shu/"/>
      <url>/2022/04/27/yue-shu/</url>
      
        <content type="html"><![CDATA[<p>这是一篇有关约数的随笔</p><span id="more"></span><ul><li><a href="https://www.acwing.com/problem/content/871/">试除法求约数</a></li><li><a href="https://www.acwing.com/activity/content/problem/content/939/">求n个数的乘积的约数个数</a></li><li><a href="https://www.acwing.com/problem/content/873/">求n个数的乘积的约数之和</a></li></ul><h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><p>求小数 （ &lt;= 1e5）约数的问题一般都 不是问题，但遇到求 n 个 a 相乘的约数 （个数 &amp;&amp; 和）时，一般的暴力枚举就不太适用了</p><h2 id="求n的约数"><a href="#求n的约数" class="headerlink" title="求n的约数"></a>求n的约数</h2><p>一般来说 ，我们经常用枚举法求约数，从2 ~ n-1开始枚举，如果 n % i == 0 则这就是要求的一个约数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i = 2;i &lt; n;i ++) {    if(n%i == 0) cnt ++;}cout &lt;&lt; cnt + 2 &lt;&lt; endl; // 1 n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当 n 很小时，大概 1e5 ?，这样做是完全没有问题的，但当 n 的范围 为 <code>1 ~ 1e9</code>时，酱紫枚举是会出问题的。</p><p>我们如何去做呢？万能的数学告诉我们 要多思考。我们来看一个具体的样例  求 10 的约数<code>1 2 5 10</code>对吧分开来看 <code>1 10</code>和<code>2 5</code>之间有什么关系，</p><p>啊对对对，是 相乘为n是吧，这样我们就知道了 ，约数总是成对出现的。 这样就是得到了 <code>试除法</code>求约数。</p><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt;divisor;int main(){    int n;    cin &gt;&gt; n;    for(int i = 1;i &lt;= n/i;i ++)        if(n % i == 0)         {            divisor.push_back(i); // i 放入数组            if(i != n/i) divisor.push_back(n/i);// 如果不是 i * i = n 的情况下，将 n/i加入数组        }    for(int i = 0;i &lt; divisor.size();i ++) cout &lt;&lt; divisor[i] &lt;&lt; " ";    cout &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求-n-个数乘积的约数的个数"><a href="#求-n-个数乘积的约数的个数" class="headerlink" title="求 n 个数乘积的约数的个数"></a>求 n 个数乘积的约数的个数</h2><p>如题 ： 输入 n ，并给定 n个数 a[n] ，a 的范围满足 1 &lt;= a &lt;=1e9 , 1 &lt;= n &lt;= 100, 如何解决呢？</p><p>先来分析暴力能做吗？很明显， 100 个 1000000000相乘我们没法存，即使你是 ull 也不行，所以pass暴力。</p><p>那我们如何来做这道题呢？万能的数学告诉我们，要学会思考。</p><p>数学方法：<strong>分解质因数</strong></p><p><img src="/images/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0.png"></p><p>如图，很好理解，开写</p><h3 id="分解质因数求约数个数"><a href="#分解质因数求约数个数" class="headerlink" title="分解质因数求约数个数"></a>分解质因数求约数个数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;map&lt;int,int&gt;prime; // 记录质因数 和 质因数的指数void get_divisor(int n){    for(int i = 2;i &lt;= n/i;i ++)        while(n % i == 0)         {            prime[i] ++;             n /= i;        }    if(n &gt; 1) prime[n] ++; // n }int main(){    int n;    cin &gt;&gt; n;    while(n --)    {        int a;        cin &gt;&gt; a;        get_divisor(a); // 获 得 质 因 数    }    //求个数    long long res = 1; // 记得开 long long    for(auto c : prime) res = res * (c.second + 1) % mod;     cout &lt;&lt; res &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求n个数的乘积的约数之和"><a href="#求n个数的乘积的约数之和" class="headerlink" title="求n个数的乘积的约数之和"></a>求n个数的乘积的约数之和</h2><p>接上题，如果我们要求的是 N 个数的乘积的约数之和是多少，该如何去求</p><p><del>万能的数学告诉我们……</del></p><p>数学方法和上面大抵相同</p><p><img src="/images/%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C.jpg"></p><p>计算 各质因数（等比数列）在作积。<del>数学方法，我也不懂。</del></p><p>开写</p><h3 id="分解质因数求乘积的约数之和"><a href="#分解质因数求乘积的约数之和" class="headerlink" title="分解质因数求乘积的约数之和"></a>分解质因数求乘积的约数之和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;map&lt;int,int&gt;prime;int main(){    int n;    cin &gt;&gt; n;    while(n--)    {        int a;        cin &gt;&gt; a;        // 接下来操作一样 先求出 质因数 map        for(int i = 2;i &lt;= a/i;i ++)            while(a % i == 0)             {                prime[i] ++;                a /= i;            }        if(a &gt; 1) prime[a] ++; //     }    long long ans = 1;    for(auto c : prime)     {        long long res = 1; // 不能放外面        int a = c.first;        int b = c.second;        while(b --) res = (res * a + 1) % mod; // 求出 单个的质因数 的等比数列和        ans = ans * res % mod;    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>over</p>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的桶排序</title>
      <link href="/2022/04/27/jian-dan-de-tong-pai-xu/"/>
      <url>/2022/04/27/jian-dan-de-tong-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>排序算法之桶排序</p><span id="more"></span><h1 id="排序算法之桶排序"><a href="#排序算法之桶排序" class="headerlink" title="排序算法之桶排序"></a>排序算法之桶排序</h1><h2 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h2><p>将一组数升序排序，保证所有数据处于[a,b]区间内。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>将[a,b]均匀的划分为 n 份，每一份就是一个桶，将所有的数据按大小放到桶里，每个桶独立排序，排序按顺序遍历输出每一个桶中的数据。</p><hr><p><img src="https://img-blog.csdnimg.cn/20190219081232815.png" alt="img"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="0-1-排序"><a href="#0-1-排序" class="headerlink" title="[0,1)排序"></a>[0,1)排序</h3><p>问题描述：将{0.12,0.07,0.89,0.54,0.36,0,73,0.82,0.01,0.32，0.15}升序排列</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">输入:100.12 0.07 0.89 0.54 0.36 0.73 0.82 0.01 0.32 0.15输出:0.01 0.07 0.12 0.15 0.32 0.36 0.54 0.73 0.82 0.89//代码#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int main(){    int n;    double a, fid;    vector&lt;double&gt; basket[5];        cin &gt;&gt; n;    fid = 1 / 5;    for (int i = 1; i &lt;= n;i ++){        cin &gt;&gt; a;        if(a &lt; fid)            basket[0].push_back(a);        else if(a &lt; 2 * fid)            basket[1].push_back(a);        else if(a &lt; 3 * fid)            basket[2].push_back(a);        else if(a &lt; 4 * fid)            basket[3].push_back(a);        else            basket[4].push_back(a);    }    sort(basket[0].begin(), basket[0].end());    sort(basket[1].begin(), basket[1].end());    sort(basket[2].begin(), basket[2].end());    sort(basket[3].begin(), basket[3].end());     sort(basket[4].begin(), basket[4].end());    for (int i = 0; i &lt; 5;i ++)    {        vector&lt;double&gt;::iterator it = basket[i].begin();        for (it; it != basket[i].end();it ++)        {            cout &lt;&lt; (*it) &lt;&lt; " ";        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特殊的划分"><a href="#特殊的划分" class="headerlink" title="特殊的划分"></a>特殊的划分</h3><p>输入10个整数，保证十个数在0~100之间，排序</p><pre class="line-numbers language-none"><code class="language-none">定义  bool basket[101] 初始化为false;循环输入 a 同时 basket[a] = true;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例题 ： <a href="https://www.luogu.com.cn/problem/P1059">洛谷P1059明明的随机数</a></p><p>存储图，通常会使用邻接表，邻接矩阵来存储图。邻接矩阵易于实现，但操作不便，邻接表实现起来较复杂，但易于操作。这里介绍一种简单，折中的存储方式 </p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真的是签到题吗</title>
      <link href="/2022/04/27/zhen-de-shi-qian-dao-ti-ma/"/>
      <url>/2022/04/27/zhen-de-shi-qian-dao-ti-ma/</url>
      
        <content type="html"><![CDATA[<p>大顶堆 </p><span id="more"></span><p>multiset&lt;int,greater<int> &gt; </int></p><h1 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h1><p>传送     <a href="http://cg.sau.edu.cn/acm/submit.jsp?problemID=2958">2958. 真的是签到题吗</a></p><p>【问题描述】</p><p>遍历一个已知非负整数数列。给你一个初始为空的栈和一个非负整数x。具体规则如下：</p><p>当数据大于或等于12345，如果栈空，do nothing.</p><p>当数据大于或等于12345，如果栈非空，x^=max(栈中元素)，输出x, 并将栈顶元素弹出。</p><p>当数据小于12345，将数据压入栈中。<br>【输入形式】</p><p>EOF</p><p>第一行两个整数n和x,n代表数列长度。(n&lt;=1e5 但数据较水)</p><p>接下来n个非负整数，代表数列中的n个元素。<br>【输出形式】</p><p>见问题描述。<br>【样例输入】</p><p>4 0</p><p>12344 12344 12345 12345<br>【样例输出】</p><p>12344</p><p>0</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>正常模拟会 TLE （大概率是因为找 栈中的最大值耗时）</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;set&gt;multiset 会一直保持 最大值在上面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>正常模拟 + multiset去最大值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;int stack[100005];int main(){    int n,x;    while(scanf("%d %d",&amp;n ,&amp;x) != EOF)    {        int t;        int base = 0, top = 0;        multiset&lt;int,greater&lt;int&gt; &gt;s;        for(int i = 1;i &lt;= n;i ++){            scanf("%d",&amp;t);            if(t &lt; 12345) {                stack[top ++] = t;                s.insert(t);            }            else{                if(top != base){                    x ^= *s.begin();                    printf("%d\n",x);                    s.erase(s.find(stack[top - 1]));                    top --;                }            }        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 大顶堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直线(整数端点)上的整数点</title>
      <link href="/2022/04/27/zhi-xian-zheng-shu-duan-dian-shang-de-zheng-shu-dian/"/>
      <url>/2022/04/27/zhi-xian-zheng-shu-duan-dian-shang-de-zheng-shu-dian/</url>
      
        <content type="html"><![CDATA[<p>直线(整数端点)上的整数点</p><span id="more"></span><h1 id="直线-整数端点-上的整数点"><a href="#直线-整数端点-上的整数点" class="headerlink" title="直线(整数端点)上的整数点"></a>直线(整数端点)上的整数点</h1><p>原题    <a href="http://cg.sau.edu.cn/acm/submit.jsp?problemID=2904">2904. 杀马特也要学数学</a></p><p>【问题描述】</p><p>给出平面上2个整点（横，纵坐标均为整数的点），求由这2个点连成的线段上还有多少整点（不包括端点）</p><p>【输入形式】</p><p>输入包括多组测试用例，每组测试用例包括4个整数x1，y1，x2，y2（1 &lt;= x1,y1,x2,y2 &lt;= 1e8）表示2个点的坐标。</p><p>【输出形式】</p><p>对于每组测试用例，输出一个数表示在由这2个点连成的线段上其他整点的数量（不包括端点）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;using namespace std;typedef long long ll;//  (x2 - x1)*y + (y1 - y2)*x = y1*x2 - x1*y2;//  a = (x2 - x1) , b = (y1 - y2) c = x1*y2 -y1*x2; ll a,b,c,d;ll gcd(ll a,ll b){    return b ? gcd(b,a%b):a;}int main(){    while(scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d)!=EOF)    {        ll p = abs(a - c);        ll q = abs(b - d);        if(p == 0 &amp;&amp; q == 0){            cout &lt;&lt; "0" &lt;&lt;endl;        }else{            cout &lt;&lt; gcd(p,q) - 1 &lt;&lt;endl;        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>母牛的故事</title>
      <link href="/2022/04/27/mu-niu-de-gu-shi/"/>
      <url>/2022/04/27/mu-niu-de-gu-shi/</url>
      
        <content type="html"><![CDATA[<p>这是一个经典的递归问题</p><span id="more"></span><p>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请问在第n年的时候，共有多少头母牛？</p><h1 id="母牛的故事【递归】"><a href="#母牛的故事【递归】" class="headerlink" title="母牛的故事【递归】"></a>母牛的故事【递归】</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请问在第n年的时候，共有多少头母牛？</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。</p><pre class="line-numbers language-none"><code class="language-none">2450<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。</p><pre class="line-numbers language-none"><code class="language-none">246<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>新生的牛在第四年初可以生小牛</p><p>分析 n 的各个取值</p><p>n = 1 : 1</p><p>n = 2 : 2</p><p>n = 3 : 3</p><p>n = 4 : 4</p><p>n = 5 : 6</p><p>n = 6 : 9</p><p>n = 7 : 13</p><p>n = 8 : 19</p><p>…</p><p>不难发现 第 n 年牛的数量 = 前一年牛数 + 前三年牛数 (这是新生的牛)</p><p>写出递推公式 : <em><strong>f( n ) = f(n - 1) + f(n - 3)</strong></em></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 递 归#include&lt;iostream&gt;using namespace std;int f(int n){    if(n &lt;= 4) return n;    else return f(n - 1) + f(n - 3);}int main(){    int n;    while(cin &gt;&gt; n){        if(n == 0) break;        cout &lt;&lt; f(n) &lt;&lt; endl;    }    return 0;}// 这种写法的时间复杂度太高，原因是 f(n) 被多次重复计算// 优化 记忆化递归 剪枝#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int arr[60];int f(int n){    if(n &lt;= 4) {        arr[n] = n;        return n;    }    if(arr[n] != 0) return arr[n]; // 当 f n 已经有值 就直接返回    arr[n] = f(n - 1) + f(n - 3);    return arr[n];}int main(){    int n;    memset(arr,0,sizeof(arr));    while(cin &gt;&gt; n){        if(n == 0) break;        cout &lt;&lt; f(n) &lt;&lt; endl;    }    return 0;}// 动态规划#include&lt;iostream&gt;using namespace std;int main(){    int n,arr[60];    while(cin &gt;&gt; n){        if(n == 0) break;        for(int i = 1;i &lt;= n;i ++){            if(i &lt;= 4) arr[i] = i;            else arr[i] = arr[i - 1] + arr[i - 3];        }        cout &lt;&lt; arr[n] &lt;&lt; endl;    }    return 0;}// 另一种更好的写法#include&lt;iostream&gt;using namespace std;int main(){    int n,arr[60];    for(int i = 1;i &lt;= 55;i ++){        if(i &lt;= 4) arr[i] = i;        else arr[i] = arr[i - 1] + arr[i - 3];    }    while(cin &gt;&gt; n){        if(!n) break;        else cout &lt;&lt; arr[n] &lt;&lt;endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉筛</title>
      <link href="/2022/04/27/ou-la-shai/"/>
      <url>/2022/04/27/ou-la-shai/</url>
      
        <content type="html"><![CDATA[<p>质数筛 线性筛素数</p><span id="more"></span><h1 id="质数筛-欧拉筛（线性筛）"><a href="#质数筛-欧拉筛（线性筛）" class="headerlink" title="质数筛-欧拉筛（线性筛）"></a>质数筛-欧拉筛（线性筛）</h1><p>传送门   <a href="http://cg.sau.edu.cn/acm/submit.jsp?problemID=3284&amp;pageNo=1&amp;pages=0">3284. 猫猫藏宝图</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#define MaxN 10001;using namespace std;bool vis[MaxN],isprime[MaxN]int cnt;void Prime(int n){    for(int i = 2;i &lt;= n;i ++)    {        if(!vis[i]) vis[i] = true,isprime[cnt++] = i; // 这里 可以添加 isPrime[i] = true,作标记素组        for(int j = 0;j &lt; cnt;j ++)        {            if(i * isprime[j] &gt; n) break;            vis[i * isprime[j]] = true;            if(i % isprime[j] == 0) break;        }    }    // jieshu}int main(){    int n;    while(n --)    {        int a;        cin &gt;&gt; a;        if(isPrime[a]) cout &lt;&lt; a &lt;&lt; "is a prime" &lt;&lt; endl;        else cout &lt;&lt; a &lt;&lt; "isn't a prime" &lt;&lt; endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 质数筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长连续因子</title>
      <link href="/2022/04/27/zui-chang-lian-xu-yin-zi/"/>
      <url>/2022/04/27/zui-chang-lian-xu-yin-zi/</url>
      
        <content type="html"><![CDATA[<p>给定一个数，求出它的最大连续因子</p><span id="more"></span><h1 id="最长连续因子"><a href="#最长连续因子" class="headerlink" title="最长连续因子"></a>最长连续因子</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个正整数 <em>N</em> 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 <em>N</em>，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个正整数 <em>N</em>（1&lt;<em>N</em>&lt;2^31）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 <code>因子1*因子2*……*因子k</code> 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。</p><pre class="line-numbers language-none"><code class="language-none">输入:630输出:35*6*7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>采用暴力解法，只需要知道当前的 i 能向后枚举多少位，每次更新，确保保留的是 <code>最大枚举数</code> 和 对应的 <code>i</code>。</p><pre class="line-numbers language-none"><code class="language-none">count -&gt; 最大枚举数idx -&gt; 对应的 i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;int count = 0;int nowcount = 1;int idx;int N;int now = 1;int main(){    cin &gt;&gt; N;    for(int i = 2;i &lt;= sqrt(N) + 1;i ++){        if(N % i != 0) continue;        int n = N,nowidx= 1;        nowcount = 0;        for(int j = i;n % j == 0;j ++){            nowcount ++;            n/=j;            nowidx = i;        }        if(count &lt; nowcount)            count = nowcount, idx = nowidx;    }        // 输 出    if(count == 0)        cout &lt;&lt; 1 &lt;&lt;endl &lt;&lt; N &lt;&lt;endl;    else {        cout &lt;&lt; count &lt;&lt;endl;        for(int i = 1;i &lt;= count;i ++,idx ++){            if(i != count) cout &lt;&lt; idx &lt;&lt; "*";            else cout &lt;&lt; idx &lt;&lt;endl;        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：当最大枚举数为 1 时，按照提议需要输出 1 \n N 例如 3 : 1 \n 3</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2022/04/27/shi-jian-fu-za-du/"/>
      <url>/2022/04/27/shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p>如题，复杂的模拟</p><span id="more"></span><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明</p><p>的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的</p><p>程序，于是你的机会来啦！</p><p>下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 </p><p>A++ 语言的循环结构如下：</p><pre class="line-numbers language-none"><code class="language-none">F i x y    循环体E<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中 <code>F i x y</code> 表示新建变量 i（变量 i 不可与未被销毁的变量重名）并初始化为 x，然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。</p><p>每次循环结束后 i 都会被修改成 i+1，一旦 i 大于 y 终止循环。</p><p>x 和 y 可以是正整数（x 和 y 的大小关系不定）或变量 n。</p><p>n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 </p><p><code>E</code> 表示循环体结束。</p><p>循环体结束时，这个循环体新建的变量也被销毁。 </p><p>注：本题中为了书写方便，在描述复杂度时，使用大写英文字母 <code>O</code> 表示通常意义下 <code>Θ</code> 的概念。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件第一行一个正整数 t，表示有 t（t≤10）个程序需要计算时间复杂度。</p><p>每个程序我们只需抽取其中 <code>F i x y</code> 和 <code>E</code> 即可计算时间复杂度。注意：循环结构允许嵌套。  </p><p>接下来每个程序的第一行包含一个正整数 L 和一个字符串，L 代表程序行数，字符串表示这个程序的复杂度，<code>O(1)</code> 表示常数复杂度，<code>O(n^w)</code> 表示复杂度为 </p><p>n^w，其中 w 是一个小于 100 的正整数（输入中不包含引号），输入保证复杂度只有 <code>O(1)</code> 和 <code>O(n^w)</code> 两种类型。 </p><p>接下来 L 行代表程序中循环结构中的 <code>F i x y</code> 或者 <code>E</code>。 </p><p>程序行若以 <code>F</code> 开头，表示进入一个循环，之后有空格分离的三个字符（串）<code>i x y</code>，其中 i 是一个小写字母（保证不为 n），表示新建的变量名，x 和 y 可能是</p><p>正整数或 n，已知若为正整数则一定小于 100。  </p><p>程序行若以 <code>E</code> 开头，则表示循环体结束。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件共 t 行，对应输入的 t 个程序，每行输出 <code>Yes</code> 或 <code>No</code> 或者 <code>ERR</code>，若程序实际复杂度与输入给出的复杂度一致则输出 <code>Yes</code>，不一致则输出 <code>No</code>，若程序有</p><p>语法错误（其中语法错误只有: ① F 和 E 不匹配 ② 新建的变量与已经存在但未被销毁的变量重复两种情况），则输出 <code>ERR</code>。</p><p>注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 <code>ERR</code>。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>输入：</p><pre class="line-numbers language-none"><code class="language-none">82 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">YesYesERRYesNoYesYesERR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这是一道模拟题</p><p><strong>字符串</strong></p><p><code>输入的时间复杂度判断</code> : 题目中只会出现两种时间复杂度<code>O(1)</code>、 <code>O(n^w)</code> 而 O(1) 的 字符串长度为 4 , O(n ^ w)的字符长度一定大于 4 ，以此 为判断。</p><p><code>字符串读入</code>：一整行的读入，使用<code>getline(is_,string)</code>读入带空格的字符串, c++ 11 中 gets() 函数不被定义，<code>online judge</code>可能报错。</p><pre class="line-numbers language-none"><code class="language-none">string str;getline(cin,str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>F E 匹配</strong></p><p>判断 F E 是否匹配，类似于<strong>括号匹配问题</strong> 定义一个<code>FEn</code> 当读入 F 时 FEn ++, 读入 E 时FEn –, 当 <code>FEn &lt; 0</code> ||<code>（读入最后一行代码时）FEn != 0</code>，表明 F E是 不匹配的。</p><p>注意：输入的 L 如果为奇数 如 1 ，3 ，5 那么 ，E F 一定不匹配</p><p><strong>时间复杂度不匹配</strong></p><p>根据O(1) 和 O(n^w) 的字符串长度 得到 目标时间复杂度。</p><pre class="line-numbers language-none"><code class="language-none">// 提取 w if(the_o){w = 0;for(int i = 0;i &lt; strlen(time);i ++)if(time[i] &gt;= '0' &amp;&amp; time[i] &lt;= '9') w = w * 10 + time[i] - '0';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 匹配的逻辑，当我们输入 E 时，就是结束一层循环，最近的 F 与这个 E 匹配，简而言之就是 <code>后输入的 先被匹配</code>，用栈存：检测到读入的是 F 语句，就将 <code>F i x y</code> 中的 i x y 入栈，遇到 E 就将 i x y 出栈。</p><pre class="line-numbers language-none"><code class="language-none">// struct node {    string i,x,y;};while(i &lt; L){    getline(a);    node stack[101]; // 数 组 栈    int base = 0, top = base;    if(a[0] == 'F'){        // 入 栈    }    if(a[0] == 'E'){        // 出 栈    }    i ++;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出栈之前 遍历 整个栈 ，判断是否 <code>变量重复</code>。</p><p>对于时间复杂度的判断，定义一个 string <code>stime</code>字符串，出栈之前 将 当前循环的时间复杂度存入stime，</p><p>循序截断 ：1</p><p>常数复杂度：c</p><p>n^1复杂度：n</p><p>计算最大时间复杂度并取最大值。</p><p>例如对</p><pre class="line-numbers language-none"><code class="language-none">F a 76 nF b 34 nF c 16 nF d 2 nF e 5 nF f 87 nF g 8 nF h 3 nF i n 17EEEEEEEEEstime : FFFFFFFFF1EnEnEnEnEnEnEnEnE时间复杂度为 n^8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>1</code>状态为截断，即 <code>1</code>循环以内的都不执行，不算时间复杂度</p><p>体现在stime就是1以前的不计算时间复杂度，因为，1以前的是先出栈的，在1循环的内部，被截断</p><p>通过得到的实际时间复杂度，与目标时间复杂度相符为 Yes ,否为 No。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#define MAXSIZE 100using namespace std;struct node{string i,x,y;};int t = 0;int Tonumber(string a) // 将 string 转为 int{int len = a.length();int  n = 0;for(int i = 0;i &lt; len;i ++){n = n * 10 + a[i];}return n;}int checkTime(string a) // 根据 stime 判断时间复杂度{int len = a.length();int t = 0,maxt = -1;char stack[1005];int base = 0,top = base;bool change = false;bool fg[len + 1];memset(fg,true,sizeof(fg));for(int i = 1;i &lt; len;i ++){t = 0;if(a[i] == 'E' &amp;&amp; (a[i + 1] == 'F' || a[i + 1] == '\0')){for(int j = i;j &gt;= 0 ;j --){if(a[j] == 'n') t ++;if(a[j] == 'F') break;if(a[j] == '1'){                    // 读 到 1 就 可 以 退 出if(maxt &lt; t) maxt = t;t = 0;break;}}            if(maxt &lt; t) maxt = t;}}return maxt;}void func(){int L,FEn = 0,n,w; // O(n^w)bool the_o = true;char time[10];cin &gt;&gt; L &gt;&gt; time;getchar();if(strlen(time) == 4) the_o = false;if(the_o){w = 0;for(int i = 0;i &lt; strlen(time);i ++){if(time[i] &gt;= '0' &amp;&amp; time[i] &lt;= '9') w = w * 10 + time[i] - '0';}}//cout &lt;&lt; the_o &lt;&lt; endl;string code[105];if(L&amp;1){for(int i = 0;i &lt; L;i ++){getline(cin,code[i]);}// @ L 为 奇 数cout &lt;&lt; "ERR" &lt;&lt; endl;return ;}else{bool outcome = true;string stime = "";node stack[101];int top = 0, base = 0;int max_w = -1;bool Notips = true;for(int i = 0;i &lt; L;i ++){getline(cin,code[i]);// cout &lt;&lt; code[i] &lt;&lt; endl;            if(code[i][0] == 'F') {FEn ++;stime = stime + "F";// 变 量 入 栈bool spaceshow = false;stack[top].i = code[i][2];for(int j = 4;j &lt; code[i].length();j ++){if(code[i][j] == ' ') {spaceshow = true;continue;}if(!spaceshow) stack[top].x += code[i][j];else stack[top].y += code[i][j];}//cout &lt;&lt;"栈："&lt;&lt; stack[top].i &lt;&lt; " " &lt;&lt; stack[top].x &lt;&lt; " " &lt;&lt; stack[top].y &lt;&lt; endl;   // 调 试 top ++;}bool once = false;if(code[i][0] == 'E' &amp;&amp; FEn &gt; 0) {FEn --;once = true;// 1. 判 断 变 量 重 名int ftop = base;//cout &lt;&lt; "zhan:" &lt;&lt;base &lt;&lt; " " &lt;&lt; top &lt;&lt;endl;   // 调 试 for(;ftop &lt; top - 1;ftop ++){if(stack[ftop].i == stack[top - 1].i) {outcome = false;break;}}// 2. 标 记 时 间 复 杂 度 @ stime//stime = "F" + stime;if(stack[top - 1].x == "n" &amp;&amp; stack[top - 1].y != "n") stime += "1";else if(stack[top - 1].y == "n") {if(stack[top - 1].x != "n") stime += "n";else stime += "c";}else if(Tonumber(stack[top - 1].x) &gt; Tonumber(stack[top -1].y)) stime += "1";else if(Tonumber(stack[top - 1].x) &lt;= Tonumber(stack[top -1].y)) stime += "c";stime += "E";stack[top - 1] = {"","",""};top--; // 遇 到 E 就 将 变 量 出 栈}if(code[i][0] == 'E' &amp;&amp; !once) FEn --;if(FEn == 0){//cout &lt;&lt; "stime :" &lt;&lt; stime &lt;&lt; endl;   // 调 试 int t = checkTime(stime);if(max_w &lt; t) max_w = t;stime = "";}if(FEn &lt; 0 || (FEn != 0 &amp;&amp; i == L - 1)) { outcome = false;} // @ EF 不匹配}//cout &lt;&lt; "the_w :" &lt;&lt; max_w &lt;&lt; endl;   // 调 试 if(the_o &amp;&amp; max_w != w) Notips = false;else{Notips = true;}if(!outcome) {cout &lt;&lt; "ERR" &lt;&lt;endl;} // @else if(outcome &amp;&amp; Notips){cout &lt;&lt; "Yes" &lt;&lt;endl;}else if(outcome &amp;&amp; !Notips){cout &lt;&lt; "No" &lt;&lt;endl;}}}int main(){cin &gt;&gt; t;for(int i = 0;i &lt; t;i ++){func();}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 字符串模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2022/04/27/kuai-su-mi/"/>
      <url>/2022/04/27/kuai-su-mi/</url>
      
        <content type="html"><![CDATA[<p>快速幂&amp;&amp;取模</p><span id="more"></span><h1 id="快速幂-amp-amp-取模"><a href="#快速幂-amp-amp-取模" class="headerlink" title="快速幂&amp;&amp;取模"></a>快速幂&amp;&amp;取模</h1><p>问题描述：求 a^n mod p 的结果</p><p>0≤a,n≤10(9)<br>1≤p≤10(9)</p><p><a href="https://www.acwing.com/problem/content/91/">AcWing原题链接</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="快速幂模板"><a href="#快速幂模板" class="headerlink" title="快速幂模板"></a>快速幂模板</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#define ll long longusing namespace std;ll QuickMi(ll a,ll n){    ll ans = 1;    while(n)    {        if(n&amp;1)        {            ans = a;        }        a *= a;        n &gt;&gt;= 1;    }    return ans;}int main(){    ll a,b;    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; QuickMi(a,b);       return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="快速幂求余"><a href="#快速幂求余" class="headerlink" title="快速幂求余"></a>快速幂求余</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#define long long llusing namespace std;ll QuickMi(ll a,ll n,ll p){    ll res = 1 % p;    while(n)    {        if(n &amp; 1)        {            res = (res * a) % p;        }        a = (a * a) % p;        n &gt;&gt;= 1;    }    return res;}ll a,b,p;int main(){    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;    cout &lt;&lt; QuickMi(a,b,p) &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>化学狂暴</title>
      <link href="/2022/04/27/hua-xue-kuang-bao/"/>
      <url>/2022/04/27/hua-xue-kuang-bao/</url>
      
        <content type="html"><![CDATA[<p>如题</p><span id="more"></span><p>在那遥远的钦钦草原，住着Yazid和YJQQQAQ，他们都是炼金术士。 </p><h1 id="P4029-Code-2-化学狂暴"><a href="#P4029-Code-2-化学狂暴" class="headerlink" title="P4029 [Code+#2]化学狂暴"></a>P4029 [Code+#2]化学狂暴</h1><p>传送  <a href="https://www.luogu.com.cn/problem/P4029">P4029 [Code+#2]化学狂暴</a></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>茉莉提</p><p>题目中 m 是迷惑性的存在</p><p>可以将 m 一直视为 m = 3的情况，即 “ 如果m=3，则Yazid在书写方程式时一定不会省略“单一元素”的下标，也一定不会省略“虚无元素”。”</p><p>思路</p><p>@ 数组模拟 26 位字符 A ~ Z  、 mp[A] = num_a, 解释为 字母A出现了num_a次 </p><p>mp1[] –&gt; 记录 等号之前的 A ~ Z 的位数</p><p>mp2[] –&gt; 记录 等号之后的 A ~ Z 的位数</p><p>@ 读取字符</p><p>当 str[i] = A ~ Z 时 更新mp1 / mp2 的值</p><p>具体更新为多少呢？</p><p>规则：</p><pre class="line-numbers language-none"><code class="language-none">对 str[i]:当str[i + 1]为 A ~ Z、 +、=、'\0'（最后一位时） ==&gt;  + 1;当str[i + 1]为 0 - 9 数字 调用函数计算 后续的数字和 如 A23D45 发现2 计算得到23 发现4,计算得到45注意要分情况讨论 ？ 在 = 左还是右<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后用ans[] = mp 作差得到 A~Z各位数</p><p>输出非零的 A~Z（注意边界）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int change(string sss){  // 计数函数    int m = sss.length();    int num = 0;    for(int i = 0;i &lt; m;i ++){        num += (sss[m - i - 1] - '0') * pow(10.0,i);    }    return num;}int main(){    //map&lt;char,int&gt; mp1,mp2;    int n,m;    int mp1[300],mp2[300];    cin &gt;&gt; n &gt;&gt; m;    for(int q = 0;q &lt; n;q ++)    {        for(int i = 0;i &lt; 26;i ++){            mp1[i + 'A'] = 0;            mp2[i + 'A'] = 0;        }                char str[1000];        cin &gt;&gt; str;        bool flag = false;        bool pesition = false;        int len = strlen(str);        //cout &lt;&lt; len &lt;&lt; endl;        for(int j = 0;j &lt; len;j ++)        {            if(str[j] == '=') { flag = true;continue;} // 判断等号是否出现            if(str[j] == '?' &amp;&amp; flag){ pesition = true;continue;}// 判断 ？ 号位置            bool tag = 0;            if(str[j] &lt;= 'Z' &amp;&amp; str[j] &gt;= 'A') tag = 1;            if(tag){                if(!flag){                    if((str[j + 1] &lt;= 'Z' &amp;&amp; str[j + 1] &gt;= 'A') || str[j + 1] == '+' || str[j + 1] == '='|| str[j + 1] == '\0') mp1[str[j]] ++;                    else if(str[j + 1] &lt;= '9' &amp;&amp; str[j + 1] &gt;= '0'){                        string sss = "";                        for(int ant = j + 1;str[ant] &lt;= '9' &amp;&amp; str[ant] &gt;= '0';ant ++){                            sss += str[ant];                        } // 计数                        mp1[str[j]] += change(sss);                    }                }                else{                    if((str[j + 1] &lt;= 'Z' &amp;&amp; str[j + 1] &gt;= 'A') || str[j + 1] == '+' || str[j + 1] == '=' || str[j + 1] == '\0') mp2[str[j]] ++;                    else if(str[j + 1] &lt;= '9' &amp;&amp; str[j + 1] &gt;= '0'){                        string sss = "";                        for(int ant = j + 1;str[ant] &lt;= '9' &amp;&amp; str[ant] &gt;= '0';ant ++){                            sss += str[ant];                        } // 计数                        mp2[str[j]] += change(sss);                    }                }            }        }        int ans[300];        for(int i = 0;i &lt; 26;i ++)  ans[i + 'A'] = 0;        for(int i = 0;i &lt; 26;i ++){            if(mp1[i + 'A'] || mp2[i + 'A']){                if(pesition)    ans[i + 'A'] = mp1[i + 'A'] - mp2[i + 'A']; // 问号在右边                else ans[i + 'A'] = mp2[i + 'A'] - mp1[i + 'A']; // ？在左边            }        }        // ans 中出现负数、最大值出现大于9，最大值小于等于 0 的 输出 “No”        if(*(max_element(ans + 'A',ans + 'Z' + 1)) &gt; 9 || *(min_element(ans+'A',ans + 'Z'  + 1)) &lt; 0 || *(max_element(ans+'A',ans+'Z' + 1)) &lt;= 0) cout &lt;&lt; "No Solution";        else{            for(int i = 0;i &lt; 26;i ++){                if(ans[i + 'A']){                    printf("%c",i + 'A');                    if(ans[i + 'A'] != 1) cout &lt;&lt; ans[i + 'A'];                }                }        }        cout &lt;&lt; endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minesweeping</title>
      <link href="/2022/04/27/minesweeping/"/>
      <url>/2022/04/27/minesweeping/</url>
      
        <content type="html"><![CDATA[<p>Mine sweeping 扫雷游戏（纯暴力遍历） <a href="https://www.dotcpp.com/oj/problem1096.html">原题连接</a></p><span id="more"></span><h1 id="扫雷"><a href="#扫雷" class="headerlink" title="扫雷"></a>扫雷</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Minesweeper Have you ever played Minesweeper? This cute little game comes with a certain operating system whose name we can’t remember. The goal of the game is to find where all the mines are located within a M x N field. The game shows a number in a square which tells you how many mines there are adjacent to that square. Each square has at most eight adjacent squares. The 4 x 4 field on the left contains two mines, each represented by a ``*’’ character. If we represent the same field by the hint numbers described above, we end up with the field on the right: <em>… …. .</em>.. …. <em>100 2210 1</em>10 1110</p><p>翻译 【 <a href="https://fanyi.so.com/#">前往360翻译</a> 】</p><p>扫雷 你玩过扫雷吗？这个可爱的小游戏带有一个我们不记得名字的操作系统。游戏的目标是找出所有地雷在 M x N 区域内的位置。游戏会在方块中显示一个数字，告诉您该方块附近有多少地雷。每个方格最多有八个相邻方格。左边的 4 x 4 区域包含两个地雷，每个地雷由一个“<em>”字符表示。如果我们用上述提示编号表示相同的字段，我们最终会得到右侧的字段：</em>… …. .*.. …. <em>100 2210 1</em>10 1110</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>The input will consist of an arbitrary number of fields. The first line of each field contains two integers n and m ( 0 &lt; n, m$ \le$100) which stand for the number of lines and columns of the field, respectively. Each of the next n lines contains exactly m characters, representing the field. Safe squares are denoted by <code>'.' and mine squares by '*'</code>, both without the quotes. The first field line where n = m = 0 represents the end of input and should not be processed.</p><p>翻译 【 <a href="https://fanyi.so.com/#">前往360翻译</a> 】</p><p>输入将由任意数量的字段组成。每个字段的第一行包含两个整数 n 和 m ( 0 &lt; n, m$ \le$100)，分别代表字段的行数和列数。接下来的 n 行中的每一行都恰好包含 m 个字符，代表该字段。安全方格用“.”表示，地雷方格用“*,”表示，两者都没有引号。n = m = 0 的第一条场线表示输入结束，不应处理。</p><pre class="line-numbers language-none"><code class="language-none">4 4*........*......3 5**.........*...0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each field, print the message Field #x: on a line alone, where x stands for the number of the field starting from 1. The next n lines should contain the field with the ``.’’ characters replaced by the number of mines adjacent to that square. There must be an empty line between field outputs.</p><p>翻译 【 <a href="https://fanyi.so.com/#">前往360翻译</a> 】</p><p>对于每个字段，仅在一行上打印消息 Field #x:，其中 x 代表从 1 开始的字段编号。接下来的 n 行应包含字段，并将“.”字符替换为那个广场附近的地雷。字段输出之间必须有一个空行。</p><pre class="line-numbers language-none"><code class="language-none">字段#1：*10022101*101110字段#2：**100332001*100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>根据题意找出每一个坐标周围的所有炸弹数，简单分析可以知道，可以对当前的坐标遍历四周8个（最多）位置，每当出现了一个炸弹，计数 ans ++…….</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int n, m;bool field[105][105];int ans[105][105];void find(int i,int j) // 对当前的field[i][j] 计数{if(field[i][j])return ;for (int t = i - 1; t &lt;= i + 1;t ++){for (int T = j - 1; T &lt;= j + 1;T ++){if(field[t][T])ans[i][j]++;}}}int main(){int idx = 1;while(cin &gt;&gt; n &gt;&gt;m){if(n == 0 &amp;&amp; m == 0)break;        // 初始化数组 field  ansfor (int i = 0; i &lt;= n + 1;i ++){memset(field[i],false,sizeof(field[i]));memset(ans[i], 0, sizeof(ans[i]));}char ch;for (int i = 1; i &lt;= n;i ++){for (int j = 1; j &lt;= m;j ++){cin &gt;&gt; ch;if(ch == '.')field[i][j] = false;if(ch == '*')field[i][j] = true;}}               // eeee 太水了for (int i = 1; i &lt;= n;i ++){for (int j = 1; j &lt;= m;j ++){find(i, j);}}cout &lt;&lt; "Field #" &lt;&lt; idx++ &lt;&lt; ":" &lt;&lt; endl;for (int i = 1; i &lt;= n;i ++){for (int j = 1; j &lt;= m;j ++){if(field[i][j])cout &lt;&lt; "*";elsecout &lt;&lt; ans[i][j];}cout &lt;&lt; endl;}cout &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建上线</title>
      <link href="/2022/04/27/hexo-bo-ke-da-jian-shang-xian/"/>
      <url>/2022/04/27/hexo-bo-ke-da-jian-shang-xian/</url>
      
        <content type="html"><![CDATA[<p>A NEW BLOG    </p><span id="more"></span><h1 id="Hexo博客搭建上线"><a href="#Hexo博客搭建上线" class="headerlink" title="Hexo博客搭建上线"></a>Hexo博客搭建上线</h1><h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><blockquote><p>首先 安装node js </p><p>网址：nodejs.org</p></blockquote><p>下载安装完成，运行  cmd 管理员模 式</p><pre class="line-numbers language-none"><code class="language-none"># 检测nodejs是否成功node -vnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>npm 安装太慢 ，安装cnpm镜像</p><pre class="line-numbers language-none"><code class="language-none">npm install -g cnpm --registry=https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看cnpm版本</p><pre class="line-numbers language-none"><code class="language-none">cnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装hexo框架"><a href="#安装hexo框架" class="headerlink" title="安装hexo框架"></a>安装hexo框架</h2><pre class="line-numbers language-none"><code class="language-none">cnpm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看hexo版本</p><pre class="line-numbers language-none"><code class="language-none">hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>建立blog文件夹</p><pre class="line-numbers language-none"><code class="language-none">#windows直接新建 然后命令行找到 blog文件cd blog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在blog路径下  注意是 <code>blog路径</code> 下运行 cmd</p><pre class="line-numbers language-none"><code class="language-none">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完成后可以使用 dir 查看生成的文件夹</p><p>安装git插件</p><pre class="line-numbers language-none"><code class="language-none">cnpm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更改 blog 路径下的 _config 文件，直接vscode打开</p><p>修改最后的 代码为</p><pre class="line-numbers language-none"><code class="language-none">deploy:type: gitrepo: # 路径如下图 https(gitee) 若部署到 github就是 yourname.github.io.gitbranch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\CHEN\AppData\Roaming\Typora\typora-user-images\image-20220303203724216.png" alt="image-20220303203724216"></p><h2 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h2><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo g # 生成网页静态文件hexo s # 预览，可不执行 本地端口 http://localhost:4000/hexo d # 向远端推数据文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装-next-主题"><a href="#安装-next-主题" class="headerlink" title="安装 next 主题"></a>安装 next 主题</h2><p>通过Git来安装</p><blockquote><p>首先在 hexo 站点路径下打开 cmd </p><blockquote><p>输入 <code> git clone https://github.com/theme-next/hexo-theme-next themes/next</code> 这是更新后的的 next 主题</p><blockquote><p>启用 next 在站点_config文件中修改</p><p>theme: next</p><p>至此、主题启用成功</p></blockquote></blockquote></blockquote><p>详情 ：Next使用手册 ：<a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识散记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公约数</title>
      <link href="/2022/04/27/zui-da-gong-yue-shu/"/>
      <url>/2022/04/27/zui-da-gong-yue-shu/</url>
      
        <content type="html"><![CDATA[<p>问：求两个整数的最大公约数</p><span id="more"></span><h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><h3 id="GCD【递归】"><a href="#GCD【递归】" class="headerlink" title="GCD【递归】"></a>GCD【递归】</h3><p>求最大公约数我只用下面这个，用别的咳嗽，不过大量取模会消耗性能</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int gcd(int x,int y){    return !y ? x : gcd(y,x%y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="辗转相除-while"><a href="#辗转相除-while" class="headerlink" title="辗转相除(while)"></a>辗转相除(while)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int gcd(int x,int y){    while(y)    {        int tmp = y;        y = x%y;        x = tmp;    }    return x;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int gcd(int x,int y){    while(x != y)    {        if(x &gt; y) x -= y;        if(y &gt; x) y -= x;    }    // x || y 就是 最大公约数}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="外挂【位运算？】"><a href="#外挂【位运算？】" class="headerlink" title="外挂【位运算？】"></a><del>外挂</del>【位运算？】</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// @ firstint gcd(int x,int y){    while(y&gt;0)    {        x=x%b;        /// --&gt;求出余数赋给a；        y=y^x;          ///--&gt;通过亦或运算，b的值变为其他值        x=x^y;          ///--&gt;a的值变为原b的值        y=y^x;          ///--&gt;b的值变为原a的值     }    return  x;}// @ secondint gcd(int x,int y){    while(y^=x^=y^=x%=y);  // 后前后前后     return x;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cylinder</title>
      <link href="/2022/04/27/cylinder/"/>
      <url>/2022/04/27/cylinder/</url>
      
        <content type="html"><![CDATA[<p>Cylinder 【<del>学霸题</del>】圆柱体 <a href="https://www.dotcpp.com/oj/problem1111.html">原题连接</a></p><span id="more"></span><h1 id="圆柱体"><a href="#圆柱体" class="headerlink" title="圆柱体"></a>圆柱体</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Using a sheet of paper and scissors, you can cut out two faces to form a cylinder in the following way:</p><p>Cut the paper horizontally (parallel to the shorter side) to get two rectangular parts.</p><p>From the first part, cut out a circle of maximum radius. The circle will form the bottom of the cylinder.</p><p>Roll the second part up in such a way that it has a perimeter of equal length with the circle’s circumference, and attach one end of the roll to the circle. Note that the roll may have some overlapping parts in order to get the required length of the perimeter.</p><p>Given the dimensions of the sheet of paper, can you calculate the biggest possible volume of a cylinder which can be constructed using the procedure described above?</p><p>翻译【<a href="https://translate.google.cn/?sl=en&amp;tl=zh-CN&amp;op=translate">点击前往谷歌翻译</a>】</p><p>使用一张纸和剪刀，您可以通过以下方式剪出两个面以形成一个圆柱体：</p><p>水平切割纸张（平行于较短的一侧）以获得两个矩形部分。</p><p>从第一部分切出一个最大半径的圆。圆圈将形成圆柱体的底部。</p><p>将第二部分卷起来，使其周长与圆的周长相等，并将卷的一端连接到圆上。请注意，为了获得所需的周长长度，卷筒可能有一些重叠部分。</p><p>给定这张纸的尺寸，你能计算出可以使用上述过程构造的圆柱体的最大可能体积吗？</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>The input consists of several test cases. Each test case consists of two numbers w and h (1 ≤ w ≤ h ≤ 100), which indicate the width and height of the sheet of paper.</p><p>The last test case is followed by a line containing two zeros.</p><p>翻译【<a href="https://translate.google.cn/?sl=en&amp;tl=zh-CN&amp;op=translate">点击前往谷歌翻译</a>】</p><p>输入由几个测试用例组成。每个测试用例由两个数字 w 和 h（1 ≤ w ≤ h ≤ 100）组成，分别表示纸张的宽度和高度。</p><p>最后一个测试用例后面是包含两个零的行。</p><pre class="line-numbers language-none"><code class="language-none">10 1010 5010 300 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>For each test case, print one line with the biggest possible volume of the cylinder. Round this number to 3 places after the decimal point.</p><p>翻译【<a href="https://translate.google.cn/?sl=en&amp;tl=zh-CN&amp;op=translate">点击前往谷歌翻译</a>】</p><p>对于每个测试用例，打印一条具有最大可能圆柱体体积的行。将此数字四舍五入到小数点后 3 位。</p><pre class="line-numbers language-none"><code class="language-none">54.247785.398412.095<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>根据题意</p><p>可以分为两种情况：</p><hr><p><img src="/images/Cylinder.png"></p><p>【Ⅰ】 以 W 为周长 h - 2 r 为高的圆柱体</p><p>条件 ：</p><p>W &gt;= 2 × pi × r ==&gt; r&lt;= w / (2 × pi)</p><p>V1 = pi × r × r ×（h - 2 × r）</p><p>【Ⅱ】以 h - 2 r为周长 w 为高的圆柱体</p><p>条件：</p><p>h - 2r &gt;= 2 × pi × r ==&gt; r &lt;= h / (2 × r + 2 × pi)</p><p>V2 = pi × r × r × w</p><p>情况【Ⅱ】中，r × 2 可能大于 w， 故 当 r × 2 &gt; w 时 r 只能 等于 w/2.</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;iomanip&gt;#define pi 3.1415926535898using namespace std;int main(){    double h,w;    while(cin &gt;&gt; w &gt;&gt; h){        if(w == 0 || h == 0) break;        double r,v1,v2;        r = w / (2*pi);        v1 = pi * r * r * (h - 2 * r);        r = h / (2*pi + 2); // 情况2        if(r*2 &gt; w) r = w/2;        v2 = pi * r * r * w;        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; max(v1,v2) &lt;&lt; endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII 码对照表</title>
      <link href="/2022/04/27/ascii-ma/"/>
      <url>/2022/04/27/ascii-ma/</url>
      
        <content type="html"><![CDATA[<p>这是一个 ASCII 码 对 照 表</p><span id="more"></span><h1 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a><em>ASCII码表</em></h1><pre class="line-numbers language-none"><code class="language-none">32 -&gt; 126 `是可见的`ASCII字符<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://www.asciitable.com/asciifull.gif" alt="ASCII码表" style="zoom:200%;"><h1 id="ASCII扩展码"><a href="#ASCII扩展码" class="headerlink" title="ASCII扩展码"></a>ASCII扩展码</h1><img src="https://www.asciitable.com/extend.gif" alt="ASCII扩展码" style="zoom:200%;">]]></content>
      
      
      
        <tags>
            
            <tag> 知识散记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
